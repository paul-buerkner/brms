% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/brmsfit-methods.R
\name{fitted.brmsfit}
\alias{fitted.brmsfit}
\title{Extract Model Fitted Values of \code{brmsfit} Objects}
\usage{
\method{fitted}{brmsfit}(object, newdata = NULL, re_formula = NULL,
  scale = c("response", "linear"), allow_new_levels = FALSE,
  sample_new_levels = FALSE, incl_autocor = TRUE, auxpar = NULL,
  subset = NULL, nsamples = NULL, sort = FALSE, summary = TRUE,
  robust = FALSE, probs = c(0.025, 0.975), ...)
}
\arguments{
\item{object}{An object of class \code{brmsfit}}

\item{newdata}{An optional data.frame for which to evaluate predictions.
If \code{NULL} (default), the orginal data of the model is used.}

\item{re_formula}{formula containing group-level effects 
to be considered in the prediction. 
If \code{NULL} (default), include all group-level effects; 
if \code{NA}, include no group-level effects.}

\item{scale}{Either \code{"response"} or \code{"linear"}. 
If \code{"response"} results are returned on the scale 
of the response variable. If \code{"linear"} 
fitted values are returned on the scale of the linear predictor.}

\item{allow_new_levels}{A flag indicating if new
levels of group-level effects are allowed 
(defaults to \code{FALSE}). 
Only relevant if \code{newdata} is provided.}

\item{sample_new_levels}{A flag indicating whether to include 
group-level uncertainty in predictions or to sample new levels 
for grouping factors specified in \code{re_formula}.
If \code{FALSE} (default), include group-level uncertainty
in the predictions. If \code{TRUE}, sample new levels from 
the group-level posterior distribution. One sample from the 
group-level posterior is drawn for each new level of the 
grouping factor(s). This feature may be useful for conducting 
Bayesian power analysis.
Only relevant if \code{newdata} is provided and 
\code{allow_new_levels} is set to \code{TRUE}.}

\item{incl_autocor}{A flag indicating if autocorrelation
parameters should be included in the predictions. 
Defaults to \code{TRUE}.}

\item{auxpar}{Optional name of a predicted auxiliary parameter.
If specified, fitted values of this parameters are returned.}

\item{subset}{A numeric vector specifying
the posterior samples to be used. 
If \code{NULL} (the default), all samples are used.}

\item{nsamples}{Positive integer indicating how many 
posterior samples should be used. 
If \code{NULL} (the default) all samples are used.
Ignored if \code{subset} is not \code{NULL}.}

\item{sort}{Logical. Only relevant for time series models. 
Indicating whether to return predicted values in the original 
order (\code{FALSE}; default) or in the order of the 
time series (\code{TRUE}).}

\item{summary}{Should summary statistics 
 (i.e. means, sds, and 95\% intervals) be returned
instead of the raw values? Default is \code{TRUE}.}

\item{robust}{If \code{FALSE} (the default) the mean is used as 
the measure of central tendency and the standard deviation as 
the measure of variability. If \code{TRUE}, the median and the 
median absolute deivation (MAD) are applied instead.
Only used if \code{summary} is \code{TRUE}.}

\item{probs}{The percentiles to be computed by the \code{quantile} 
function. Only used if \code{summary} is \code{TRUE}.}

\item{...}{Currently ignored}
}
\value{
Fitted values extracted from \code{object}. 
 The output depends on the family:
 If \code{summary = TRUE} it is a N x E x C array 
 for categorical and ordinal models and a N x E matrix else.
 If \code{summary = FALSE} it is a S x N x C array 
 for categorical and ordinal models and a S x N matrix else.
 N is the number of observations, S is the number of samples, 
 C is the number of categories, and E is equal to \code{length(probs) + 2}.
}
\description{
Predict fitted values (i.e., the 'regression line') of a fitted model.
Can be performed for the data used to fit the model 
(posterior predictive checks) or for new data.
By definition, these predictions have smaller variance
than the response predictions performed by
the \code{\link[brms:predict.brmsfit]{predict}} method. 
This is because the measurement error is not incorporated.
The estimated means of both methods should, however, be very similar.
}
\details{
\code{NA} values within factors in \code{newdata}, 
  are interpreted as if all dummy variables of this factor are 
  zero. This allows, for instance, to make predictions of the grand mean 
  when using sum coding.
}
\examples{
\dontrun{
## fit a model
fit <- brm(rating ~ treat + period + carry + (1|subject), 
           data = inhaler)

## extract fitted values
fitted_values <- fitted(fit)
head(fitted_values)

## plot fitted means against actual response
dat <- as.data.frame(cbind(Y = standata(fit)$Y, fitted_values))
ggplot(dat) + geom_point(aes(x = Estimate, y = Y))
}

}
