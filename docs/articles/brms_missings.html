<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Handle Missing Values with brms • brms</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Handle Missing Values with brms">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">brms</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.22.12</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/brms_customfamilies.html">Define Custom Response Distributions with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_distreg.html">Estimating Distributional Models with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_families.html">Parameterization of Response Distributions in brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_missings.html">Handle Missing Values with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_monotonic.html">Estimating Monotonic Effects with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_multivariate.html">Estimating Multivariate Models with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_nonlinear.html">Estimating Non-Linear Models with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_phylogenetics.html">Estimating Phylogenetic Multilevel Models with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_threading.html">Running brms models with within-chain parallelization</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/paul-buerkner/brms/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Handle Missing Values with brms</h1>
                        <h4 data-toc-skip class="author">Paul
Bürkner</h4>
            
            <h4 data-toc-skip class="date">2025-06-24</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/paul-buerkner/brms/blob/HEAD/vignettes/brms_missings.Rmd" class="external-link"><code>vignettes/brms_missings.Rmd</code></a></small>
      <div class="d-none name"><code>brms_missings.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Many real world data sets contain missing values for various reasons.
Generally, we have quite a few options to handle those missing values.
The easiest solution is to remove all rows from the data set, where one
or more variables are missing. However, if values are not missing
completely at random, this will likely lead to bias in our analysis.
Accordingly, we usually want to impute missing values in one way or the
other. Here, we will consider two very general approaches using
<strong>brms</strong>: (1) Impute missing values <em>before</em> the
model fitting with multiple imputation, and (2) impute missing values on
the fly <em>during</em> model fitting<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;Actually, there is a third approach that only applies to
missings in response variables. If we want to impute missing responses,
we just fit the model using the observed responses and than impute the
missings &lt;em&gt;after&lt;/em&gt; fitting the model by means of posterior
prediction. That is, we supply the predictor values corresponding to
missing responses to the &lt;code&gt;predict&lt;/code&gt; method.&lt;/p&gt;"><sup>1</sup></a>. As a simple example, we will use the
<code>nhanes</code> data set, which contains information on
participants’ <code>age</code>, <code>bmi</code> (body mass index),
<code>hyp</code> (hypertensive), and <code>chl</code> (total serum
cholesterol). For the purpose of the present vignette, we are primarily
interested in predicting <code>bmi</code> by <code>age</code> and
<code>chl</code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"nhanes"</span>, package <span class="op">=</span> <span class="st">"mice"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">nhanes</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="imputation-before-model-fitting">Imputation before model fitting<a class="anchor" aria-label="anchor" href="#imputation-before-model-fitting"></a>
</h2>
<p>There are many approaches allowing us to impute missing data before
the actual model fitting takes place. From a statistical perspective,
multiple imputation is one of the best solutions. Each missing value is
not imputed once but <code>m</code> times leading to a total of
<code>m</code> fully imputed data sets. The model can then be fitted to
each of those data sets separately and results are pooled across models,
afterwards. One widely applied package for multiple imputation is
<strong>mice</strong> (Buuren &amp; Groothuis-Oudshoorn, 2010) and we
will use it in the following in combination with <strong>brms</strong>.
Here, we apply the default settings of <strong>mice</strong>, which
means that all variables will be used to impute missing values in all
other variables and imputation functions automatically chosen based on
the variables’ characteristics.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/amices/mice" class="external-link">mice</a></span><span class="op">)</span></span>
<span><span class="va">m</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="va">imp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://amices.org/mice/reference/mice.html" class="external-link">mice</a></span><span class="op">(</span><span class="va">nhanes</span>, m <span class="op">=</span> <span class="va">m</span>, print <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>Now, we have <code>m = 5</code> imputed data sets stored within the
<code>imp</code> object. In practice, we will likely need more than
<code>5</code> of those to accurately account for the uncertainty
induced by the missingness, perhaps even in the area of <code>100</code>
imputed data sets (Zhou &amp; Reiter, 2010). Of course, this increases
the computational burden by a lot and so we stick to <code>m = 5</code>
for the purpose of this vignette. Regardless of the value of
<code>m</code>, we can either extract those data sets and then pass them
to the actual model fitting function as a list of data frames, or pass
<code>imp</code> directly. The latter works because
<strong>brms</strong> offers special support for data imputed by
<strong>mice</strong>. We will go with the latter approach, since it is
less typing. Fitting our model of interest with <strong>brms</strong> to
the multiple imputed data sets is straightforward.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_imp1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/brm_multiple.html">brm_multiple</a></span><span class="op">(</span><span class="va">bmi</span> <span class="op">~</span> <span class="va">age</span><span class="op">*</span><span class="va">chl</span>, data <span class="op">=</span> <span class="va">imp</span>, chains <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>The returned fitted model is an ordinary <code>brmsfit</code> object
containing the posterior draws of all <code>m</code> submodels. While
pooling across models is not necessarily straightforward in classical
statistics, it is trivial in a Bayesian framework. Here, pooling results
of multiple imputed data sets is simply achieved by combining the
posterior draws of the submodels. Accordingly, all post-processing
methods can be used out of the box without having to worry about pooling
at all.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_imp1</span><span class="op">)</span></span></code></pre></div>
<p>In the summary output, we notice that some <code>Rhat</code> values
are higher than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1.1</mn><annotation encoding="application/x-tex">1.1</annotation></semantics></math>
indicating possible convergence problems. For models based on multiple
imputed data sets, this is often a <strong>false positive</strong>:
Chains of different submodels may not overlay each other exactly, since
there were fitted to different data. We can see the chains on the
right-hand side of</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit_imp1</span>, variable <span class="op">=</span> <span class="st">"^b"</span>, regex <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Such non-overlaying chains imply high <code>Rhat</code> values
without there actually being any convergence issue. Accordingly, we have
to investigate the convergence of the submodels separately, which we can
do for example via:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mc-stan.org/posterior/" class="external-link">posterior</a></span><span class="op">)</span></span>
<span><span class="va">draws</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/draws-brms.html">as_draws_array</a></span><span class="op">(</span><span class="va">fit_imp1</span><span class="op">)</span></span>
<span><span class="co"># every dataset has nc = 2 chains in this example</span></span>
<span><span class="va">nc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/draws-index-brms.html">nchains</a></span><span class="op">(</span><span class="va">fit_imp1</span><span class="op">)</span> <span class="op">/</span> <span class="va">m</span></span>
<span><span class="va">draws_per_dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">m</span>, </span>
<span>  \<span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="fu"><a href="https://mc-stan.org/posterior/reference/subset_draws.html" class="external-link">subset_draws</a></span><span class="op">(</span><span class="va">draws</span>, chain <span class="op">=</span> <span class="op">(</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">*</span><span class="va">nc</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">*</span><span class="va">nc</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">draws_per_dat</span>, <span class="va">summarise_draws</span>, <span class="fu"><a href="https://mc-stan.org/posterior/reference/draws_summary.html" class="external-link">default_convergence_measures</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>The convergence of each of the submodels looks good. Accordingly, we
can proceed with further post-processing and interpretation of the
results. For instance, we could investigate the combined effect of
<code>age</code> and <code>chl</code>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/conditional_effects.brmsfit.html">conditional_effects</a></span><span class="op">(</span><span class="va">fit_imp1</span>, <span class="st">"age:chl"</span><span class="op">)</span></span></code></pre></div>
<p>To summarize, the advantages of multiple imputation are obvious: One
can apply it to all kinds of models, since model fitting functions do
not need to know that the data sets were imputed, beforehand. Also, we
do not need to worry about pooling across submodels when using fully
Bayesian methods. The only drawback is the amount of time required for
model fitting. Estimating Bayesian models is already quite slow with
just a single data set and it only gets worse when working with multiple
imputation.</p>
<div class="section level3">
<h3 id="compatibility-with-other-multiple-imputation-packages">Compatibility with other multiple imputation packages<a class="anchor" aria-label="anchor" href="#compatibility-with-other-multiple-imputation-packages"></a>
</h3>
<p><strong>brms</strong> offers built-in support for
<strong>mice</strong> mainly because I use the latter in some of my own
research projects. Nevertheless, <code>brm_multiple</code> supports all
kinds of multiple imputation packages as it also accepts a <em>list</em>
of data frames as input for its <code>data</code> argument. Thus, you
just need to extract the imputed data frames in the form of a list,
which can then be passed to <code>brm_multiple</code>. Most multiple
imputation packages have some built-in functionality for this task. When
using the <strong>mi</strong> package, for instance, you simply need to
call the <code>mi::complete</code> function to get the desired
output.</p>
</div>
</div>
<div class="section level2">
<h2 id="imputation-during-model-fitting">Imputation during model fitting<a class="anchor" aria-label="anchor" href="#imputation-during-model-fitting"></a>
</h2>
<p>Imputation during model fitting is generally thought to be more
complex than imputation before model fitting, because one has to take
care of everything within one step. This remains true when imputing
missing values with <strong>brms</strong>, but possibly to a somewhat
smaller degree. Consider again the <code>nhanes</code> data with the
goal to predict <code>bmi</code> by <code>age</code>, and
<code>chl</code>. Since <code>age</code> contains no missing values, we
only have to take special care of <code>bmi</code> and <code>chl</code>.
We need to tell the model two things. (1) Which variables contain
missing values and how they should be predicted, as well as (2) which of
these imputed variables should be used as predictors. In
<strong>brms</strong> we can do this as follows:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bform</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/brmsformula.html">bf</a></span><span class="op">(</span><span class="va">bmi</span> <span class="op">|</span> <span class="fu"><a href="../reference/mi.html">mi</a></span><span class="op">(</span><span class="op">)</span> <span class="op">~</span> <span class="va">age</span> <span class="op">*</span> <span class="fu"><a href="../reference/mi.html">mi</a></span><span class="op">(</span><span class="va">chl</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/brmsformula.html">bf</a></span><span class="op">(</span><span class="va">chl</span> <span class="op">|</span> <span class="fu"><a href="../reference/mi.html">mi</a></span><span class="op">(</span><span class="op">)</span> <span class="op">~</span> <span class="va">age</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="../reference/brmsformula-helpers.html">set_rescor</a></span><span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">fit_imp2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/brm.html">brm</a></span><span class="op">(</span><span class="va">bform</span>, data <span class="op">=</span> <span class="va">nhanes</span><span class="op">)</span></span></code></pre></div>
<p>The model has become multivariate, as we no longer only predict
<code>bmi</code> but also <code>chl</code> (see
<code><a href="../articles/brms_multivariate.html">vignette("brms_multivariate")</a></code> for details about the
multivariate syntax of <strong>brms</strong>). We ensure that missings
in both variables will be modeled rather than excluded by adding
<code>| mi()</code> on the left-hand side of the formulas<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;We don’t really need this for &lt;code&gt;bmi&lt;/code&gt;, since
&lt;code&gt;bmi&lt;/code&gt; is not used as a predictor for another variable.
Accordingly, we could also – and equivalently – impute missing values of
&lt;code&gt;bmi&lt;/code&gt; &lt;em&gt;after&lt;/em&gt; model fitting by means of posterior
prediction.&lt;/p&gt;"><sup>2</sup></a>. We write
<code>mi(chl)</code> on the right-hand side of the formula for
<code>bmi</code> to ensure that the estimated missing values of
<code>chl</code> will be used in the prediction of <code>bmi</code>. The
summary is a bit more cluttered as we get coefficients for both response
variables, but apart from that we can interpret coefficients in the
usual way.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_imp2</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/conditional_effects.brmsfit.html">conditional_effects</a></span><span class="op">(</span><span class="va">fit_imp2</span>, <span class="st">"age:chl"</span>, resp <span class="op">=</span> <span class="st">"bmi"</span><span class="op">)</span></span></code></pre></div>
<p>The results look pretty similar to those obtained from multiple
imputation, but be aware that this may not be generally the case. In
multiple imputation, the default is to impute all variables based on all
other variables, while in the ‘one-step’ approach, we have to explicitly
specify the variables used in the imputation. Thus, arguably, multiple
imputation is easier to apply. An obvious advantage of the ‘one-step’
approach is that the model needs to be fitted only once instead of
<code>m</code> times. Also, within the <strong>brms</strong> framework,
we can use multilevel structure and complex non-linear relationships for
the imputation of missing values, which is not achieved as easily in
standard multiple imputation software. On the downside, it is currently
not possible to impute discrete variables, because <strong>Stan</strong>
(the engine behind <strong>brms</strong>) does not allow estimating
discrete parameters.</p>
<div class="section level3">
<h3 id="combining-measurement-error-and-missing-values">Combining measurement error and missing values<a class="anchor" aria-label="anchor" href="#combining-measurement-error-and-missing-values"></a>
</h3>
<p>Missing value terms in <strong>brms</strong> cannot only handle
missing values but also measurement error, or arbitrary combinations of
the two. In fact, we can think of a missing value as a value with
infinite measurement error. Thus, <code>mi</code> terms are a natural
(and somewhat more verbose) generalization of the now soft deprecated
<code>me</code> terms. Suppose we had measured the variable
<code>chl</code> with some known error:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nhanes</span><span class="op">$</span><span class="va">se</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html" class="external-link">rexp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">nhanes</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>Then we can go ahead an include this information into the model as
follows:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bform</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/brmsformula.html">bf</a></span><span class="op">(</span><span class="va">bmi</span> <span class="op">|</span> <span class="fu"><a href="../reference/mi.html">mi</a></span><span class="op">(</span><span class="op">)</span> <span class="op">~</span> <span class="va">age</span> <span class="op">*</span> <span class="fu"><a href="../reference/mi.html">mi</a></span><span class="op">(</span><span class="va">chl</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/brmsformula.html">bf</a></span><span class="op">(</span><span class="va">chl</span> <span class="op">|</span> <span class="fu"><a href="../reference/mi.html">mi</a></span><span class="op">(</span><span class="va">se</span><span class="op">)</span> <span class="op">~</span> <span class="va">age</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="../reference/brmsformula-helpers.html">set_rescor</a></span><span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">fit_imp3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/brm.html">brm</a></span><span class="op">(</span><span class="va">bform</span>, data <span class="op">=</span> <span class="va">nhanes</span><span class="op">)</span></span></code></pre></div>
<p>Summarizing and post-processing the model continues to work as
usual.</p>
</div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>Buuren, S. V. &amp; Groothuis-Oudshoorn, K. (2010). mice:
Multivariate imputation by chained equations in R. <em>Journal of
Statistical Software</em>, 1-68. doi.org/10.18637/jss.v045.i03</p>
<p>Zhou, X. &amp; Reiter, J. P. (2010). A Note on Bayesian Inference
After Multiple Imputation. <em>The American Statistician</em>, 64(2),
159-163. doi.org/10.1198/tast.2010.09109</p>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Paul-Christian Bürkner.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
