<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Set up a model formula for use in brms — brmsformula • brms</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Set up a model formula for use in brms — brmsformula"><meta property="og:description" content="Set up a model formula for use in the brms package
allowing to define (potentially non-linear) additive multilevel
models for all parameters of the assumed response distribution."><meta property="og:image" content="/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">


    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">brms</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">2.22.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../articles/index.html">Vignettes</a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Other Packages

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="http://mc-stan.org/rstan" class="external-link">rstan</a>
    </li>
    <li>
      <a href="http://mc-stan.org/rstanarm" class="external-link">rstanarm</a>
    </li>
    <li>
      <a href="http://mc-stan.org/bayesplot" class="external-link">bayesplot</a>
    </li>
    <li>
      <a href="http://mc-stan.org/shinystan" class="external-link">shinystan</a>
    </li>
    <li>
      <a href="http://mc-stan.org/loo" class="external-link">loo</a>
    </li>
    <li>
      <a href="http://mc-stan.org/projpred" class="external-link">projpred</a>
    </li>
    <li>
      <a href="http://mc-stan.org/rstantools" class="external-link">rstantools</a>
    </li>
  </ul></li>
<li>
  <a href="http://mc-stan.org" class="external-link">Stan</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://twitter.com/mcmc_stan" class="external-link">
    <span class="fa fa-twitter"></span>

  </a>
</li>
<li>
  <a href="https://github.com/paul-buerkner/brms" class="external-link">
    <span class="fa fa-github"></span>

  </a>
</li>
<li>
  <a href="http://discourse.mc-stan.org/" class="external-link">
    <span class="fa fa-users"></span>

  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Set up a model formula for use in <span class="pkg">brms</span></h1>
    <small class="dont-index">Source: <a href="https://github.com/paul-buerkner/brms/blob/HEAD/R/brmsformula.R" class="external-link"><code>R/brmsformula.R</code></a></small>
    <div class="hidden name"><code>brmsformula.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Set up a model formula for use in the <span class="pkg">brms</span> package
allowing to define (potentially non-linear) additive multilevel
models for all parameters of the assumed response distribution.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">brmsformula</span><span class="op">(</span></span>
<span>  <span class="va">formula</span>,</span>
<span>  <span class="va">...</span>,</span>
<span>  flist <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  family <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  autocor <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  nl <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  loop <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  center <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  cmc <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  sparse <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  decomp <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  unused <span class="op">=</span> <span class="cn">NULL</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>


<dl><dt id="arg-formula">formula<a class="anchor" aria-label="anchor" href="#arg-formula"></a></dt>
<dd><p>An object of class <code>formula</code>
(or one that can be coerced to that class):
a symbolic description of the model to be fitted.
The details of model specification are given in 'Details'.</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>Additional <code>formula</code> objects to specify predictors of
non-linear and distributional parameters. Formulas can either be named
directly or contain names on their left-hand side. Alternatively,
it is possible to fix parameters to certain values by passing
numbers or character strings in which case arguments have to be named
to provide the parameter names. See 'Details' for more information.</p></dd>


<dt id="arg-flist">flist<a class="anchor" aria-label="anchor" href="#arg-flist"></a></dt>
<dd><p>Optional list of formulas, which are treated in the
same way as formulas passed via the <code>...</code> argument.</p></dd>


<dt id="arg-family">family<a class="anchor" aria-label="anchor" href="#arg-family"></a></dt>
<dd><p>Same argument as in <code><a href="brm.html">brm</a></code>.
If <code>family</code> is specified in <code>brmsformula</code>, it will
overwrite the value specified in other functions.</p></dd>


<dt id="arg-autocor">autocor<a class="anchor" aria-label="anchor" href="#arg-autocor"></a></dt>
<dd><p>An optional <code>formula</code> which contains
autocorrelation terms as described in <code><a href="autocor-terms.html">autocor-terms</a></code>
or alternatively a <code><a href="cor_brms.html">cor_brms</a></code> object (deprecated).
If <code>autocor</code> is specified in <code>brmsformula</code>, it will
overwrite the value specified in other functions.</p></dd>


<dt id="arg-nl">nl<a class="anchor" aria-label="anchor" href="#arg-nl"></a></dt>
<dd><p>Logical; Indicates whether <code>formula</code> should be
treated as specifying a non-linear model. By default, <code>formula</code>
is treated as an ordinary linear model formula.</p></dd>


<dt id="arg-loop">loop<a class="anchor" aria-label="anchor" href="#arg-loop"></a></dt>
<dd><p>Logical; Only used in non-linear models.
Indicates if the computation of the non-linear formula should be
done inside (<code>TRUE</code>) or outside (<code>FALSE</code>) a loop
over observations. Defaults to <code>TRUE</code>.</p></dd>


<dt id="arg-center">center<a class="anchor" aria-label="anchor" href="#arg-center"></a></dt>
<dd><p>Logical; Indicates if the population-level design
matrix should be centered, which usually increases sampling efficiency.
See the 'Details' section for more information.
Defaults to <code>TRUE</code> for distributional parameters
and to <code>FALSE</code> for non-linear parameters.</p></dd>


<dt id="arg-cmc">cmc<a class="anchor" aria-label="anchor" href="#arg-cmc"></a></dt>
<dd><p>Logical; Indicates whether automatic cell-mean coding
should be enabled when removing the intercept by adding <code>0</code>
to the right-hand of model formulas. Defaults to <code>TRUE</code> to
mirror the behavior of standard <span style="R">R</span> formula parsing.</p></dd>


<dt id="arg-sparse">sparse<a class="anchor" aria-label="anchor" href="#arg-sparse"></a></dt>
<dd><p>Logical; indicates whether the population-level design matrices
should be treated as sparse (defaults to <code>FALSE</code>). For design matrices
with many zeros, this can considerably reduce required memory. Sampling
speed is currently not improved or even slightly decreased.</p></dd>


<dt id="arg-decomp">decomp<a class="anchor" aria-label="anchor" href="#arg-decomp"></a></dt>
<dd><p>Optional name of the decomposition used for the
population-level design matrix. Defaults to <code>NULL</code> that is
no decomposition. Other options currently available are
<code>"QR"</code> for the QR decomposition that helps in fitting models
with highly correlated predictors.</p></dd>


<dt id="arg-unused">unused<a class="anchor" aria-label="anchor" href="#arg-unused"></a></dt>
<dd><p>An optional <code>formula</code> which contains variables
that are unused in the model but should still be stored in the
model's data frame. This can be useful, for example,
if those variables are required for post-processing the model.</p></dd>

</dl></div>
    <div id="value">
    <h2>Value</h2>
    <p>An object of class <code>brmsformula</code>, which
  is essentially a <code>list</code> containing all model
  formulas as well as some additional information.</p>
    </div>
    <div id="details">
    <h2>Details</h2>
    <p><b>General formula structure</b></p>
<p>The <code>formula</code> argument accepts formulas of the following syntax:</p>
<p><code>response | aterms ~ pterms + (gterms | group)</code></p>
<p>The <code>pterms</code> part contains effects that are assumed to be the same
  across observations. We call them 'population-level' or 'overall' effects,
  or (adopting frequentist vocabulary) 'fixed' effects. The optional
  <code>gterms</code> part may contain effects that are assumed to vary across
  grouping variables specified in <code>group</code>. We call them 'group-level' or
  'varying' effects, or (adopting frequentist vocabulary) 'random' effects,
  although the latter name is misleading in a Bayesian context. For more
  details type <code>vignette("brms_overview")</code> and
  <code>vignette("brms_multilevel")</code>.</p>
<p><b>Group-level terms</b></p>
<p>Multiple grouping factors each with multiple group-level effects are
  possible. (Of course we can also run models without any group-level
  effects.) Instead of <code>|</code> you may use <code>||</code> in grouping terms to
  prevent correlations from being modeled. Equivalently, the <code>cor</code>
  argument of the <code><a href="gr.html">gr</a></code> function can be used for this purpose,
  for example, <code>(1 + x || g)</code> is equivalent to
  <code>(1 + x | gr(g, cor = FALSE))</code>.</p>
<p>It is also possible to model different group-level terms of the same
  grouping factor as correlated (even across different formulas, e.g., in
  non-linear models) by using <code>|&lt;ID&gt;|</code> instead of <code>|</code>. All
  group-level terms sharing the same ID will be modeled as correlated. If,
  for instance, one specifies the terms <code>(1+x|i|g)</code> and <code>(1+z|i|g)</code>
  somewhere in the formulas passed to <code>brmsformula</code>, correlations
  between the corresponding group-level effects will be estimated. In the
  above example, <code>i</code> is not a variable in the data but just a symbol to
  indicate correlations between multiple group-level terms. Equivalently, the
  <code>id</code> argument of the <code><a href="gr.html">gr</a></code> function can be used as well,
  for example, <code>(1 + x | gr(g, id = "i"))</code>.</p>
<p>If levels of the grouping factor belong to different sub-populations,
  it may be reasonable to assume a different covariance matrix for each
  of the sub-populations. For instance, the variation within the
  treatment group and within the control group in a randomized control
  trial might differ. Suppose that <code>y</code> is the outcome, and
  <code>x</code> is the factor indicating the treatment and control group.
  Then, we could estimate different hyper-parameters of the varying
  effects (in this case a varying intercept) for treatment and control
  group via <code>y ~ x + (1 | gr(subject, by = x))</code>.</p>
<p>You can specify multi-membership terms using the <code><a href="mm.html">mm</a></code>
  function. For instance, a multi-membership term with two members
  could be <code>(1 | mm(g1, g2))</code>, where <code>g1</code> and <code>g2</code>
  specify the first and second member, respectively. Moreover,
  if a covariate <code>x</code> varies across the levels of the grouping-factors
  <code>g1</code> and <code>g2</code>, we can save the respective covariate values
  in the variables <code>x1</code> and <code>x2</code> and then model the varying
  effect as <code>(1 + mmc(x1, x2) | mm(g1, g2))</code>.</p>
<p><b>Special predictor terms</b></p>
<p>Flexible non-linear smooth terms can modeled using the <code><a href="s.html">s</a></code>
  and <code><a href="s.html">t2</a></code> functions in the <code>pterms</code> part
  of the model formula. This allows to fit generalized additive mixed
  models (GAMMs) with <span class="pkg">brms</span>. The implementation is similar to that
  used in the <span class="pkg">gamm4</span> package. For more details on this model class
  see <code><a href="https://rdrr.io/pkg/mgcv/man/gam.html" class="external-link">gam</a></code> and <code><a href="https://rdrr.io/pkg/mgcv/man/gamm.html" class="external-link">gamm</a></code>.</p>
<p>Gaussian process terms can be fitted using the <code><a href="gp.html">gp</a></code>
  function in the <code>pterms</code> part of the model formula. Similar to
  smooth terms, Gaussian processes can be used to model complex non-linear
  relationships, for instance temporal or spatial autocorrelation.
  However, they are computationally demanding and are thus not recommended
  for very large datasets or approximations need to be used.</p>
<p>The <code>pterms</code> and <code>gterms</code> parts may contain four non-standard
  effect types namely monotonic, measurement error, missing value, and
  category specific effects, which can be specified using terms of the
  form <code>mo(predictor)</code>, <code>me(predictor, sd_predictor)</code>,
  <code>mi(predictor)</code>, and <code>cs(&lt;predictors&gt;)</code>, respectively.
  Category specific effects can only be estimated in
  ordinal models and are explained in more detail in the package's
  main vignette (type <code>vignette("brms_overview")</code>).
  The other three effect types are explained in the following.</p>
<p>A monotonic predictor must either be integer valued or an ordered factor,
  which is the first difference to an ordinary continuous predictor.
  More importantly, predictor categories (or integers) are not assumed to be
  equidistant with respect to their effect on the response variable.
  Instead, the distance between adjacent predictor categories (or integers)
  is estimated from the data and may vary across categories.
  This is realized by parameterizing as follows:
  One parameter takes care of the direction and size of the effect similar
  to an ordinary regression parameter, while an additional parameter vector
  estimates the normalized distances between consecutive predictor categories.
  A main application of monotonic effects are ordinal predictors that
  can this way be modeled without (falsely) treating them as continuous
  or as unordered categorical predictors. For more details and examples
  see <code><a href="../articles/brms_monotonic.html">vignette("brms_monotonic")</a></code>.</p>
<p>Quite often, predictors are measured and as such naturally contain
  measurement error. Although most researchers are well aware of this problem,
  measurement error in predictors is ignored in most
  regression analyses, possibly because only few packages allow
  for modeling it. Notably, measurement error can be handled in
  structural equation models, but many more general regression models
  (such as those featured by <span class="pkg">brms</span>) cannot be transferred
  to the SEM framework. In <span class="pkg">brms</span>, effects of noise-free predictors
  can be modeled using the <code>me</code> (for 'measurement error') function.
  If, say, <code>y</code> is the response variable and
  <code>x</code> is a measured predictor with known measurement error
  <code>sdx</code>, we can simply include it on the right-hand side of the
  model formula via <code>y ~ me(x, sdx)</code>.
  This can easily be extended to more general formulas.
  If <code>x2</code> is another measured predictor with corresponding error
  <code>sdx2</code> and <code>z</code> is a predictor without error
  (e.g., an experimental setting), we can model all main effects
  and interactions of the three predictors in the well known manner:
  <code>y ~ me(x, sdx) * me(x2, sdx2) * z</code>.
  The <code>me</code> function is soft deprecated in favor of the more flexible
  and consistent <code>mi</code> function (see below).</p>
<p>When a variable contains missing values, the corresponding rows will
  be excluded from the data by default (row-wise exclusion). However,
  quite often we want to keep these rows and instead estimate the missing values.
  There are two approaches for this: (a) Impute missing values before
  the model fitting for instance via multiple imputation (see
  <code><a href="brm_multiple.html">brm_multiple</a></code> for a way to handle multiple imputed datasets).
  (b) Impute missing values on the fly during model fitting. The latter
  approach is explained in the following. Using a variable with missing
  values as predictors requires two things, First, we need to specify that
  the predictor contains missings that should to be imputed.
  If, say, <code>y</code> is the primary response, <code>x</code> is a
  predictor with missings and <code>z</code> is a predictor without missings,
  we go for <code>y ~ mi(x) + z</code>. Second, we need to model <code>x</code>
  as an additional response with corresponding predictors and the
  addition term <code><a href="mi.html">mi()</a></code>. In our example, we could write
  <code>x | mi() ~ z</code>. Measurement error may be included via
  the <code>sdy</code> argument, say, <code>x | mi(sdy = se) ~ z</code>.
  See <code><a href="mi.html">mi</a></code> for examples with real data.</p>

<p><b>Autocorrelation terms</b></p>
<p>Autocorrelation terms can be directly specified inside the <code>pterms</code>
  part as well. Details can be found in <code><a href="autocor-terms.html">autocor-terms</a></code>.</p>
<p><b>Additional response information</b></p>
<p>Another special of the <span class="pkg">brms</span> formula syntax is the optional
  <code>aterms</code> part, which may contain multiple terms of the form
  <code>fun(&lt;variable&gt;)</code> separated by <code>+</code> each providing special
  information on the response variable. <code>fun</code> can be replaced with
  either <code>se</code>, <code>weights</code>, <code>subset</code>, <code>cens</code>, <code>trunc</code>,
  <code>trials</code>, <code>cat</code>, <code>dec</code>, <code>rate</code>, <code>vreal</code>, or
  <code>vint</code>. Their meanings are explained below
  (see also <code><a href="addition-terms.html">addition-terms</a></code>).</p>
<p>For families <code>gaussian</code>, <code>student</code> and <code>skew_normal</code>, it is
  possible to specify standard errors of the observations, thus allowing
  to perform meta-analysis. Suppose that the variable <code>yi</code> contains
  the effect sizes from the studies and <code>sei</code> the corresponding
  standard errors. Then, fixed and random effects meta-analyses can
  be conducted using the formulas <code>yi | se(sei) ~ 1</code> and
  <code>yi | se(sei) ~ 1 + (1|study)</code>, respectively, where
  <code>study</code> is a variable uniquely identifying every study.
  If desired, meta-regression can be performed via
  <code>yi | se(sei) ~ 1 + mod1 + mod2 + (1|study)</code>
  or <br><code>yi | se(sei) ~ 1 + mod1 + mod2 + (1 + mod1 + mod2|study)</code>,
  where <code>mod1</code> and <code>mod2</code> represent moderator variables.
  By default, the standard errors replace the parameter <code>sigma</code>.
  To model <code>sigma</code> in addition to the known standard errors,
  set argument <code>sigma</code> in function <code>se</code> to <code>TRUE</code>,
  for instance, <code>yi | se(sei, sigma = TRUE) ~ 1</code>.</p>
<p>For all families, weighted regression may be performed using
  <code>weights</code> in the <code>aterms</code> part. Internally, this is
  implemented by multiplying the log-posterior values of each
  observation by their corresponding weights.
  Suppose that variable <code>wei</code> contains the weights
  and that <code>yi</code> is the response variable.
  Then, formula <code>yi | weights(wei) ~ predictors</code>
  implements a weighted regression.</p>
<p>For multivariate models, <code>subset</code> may be used in the <code>aterms</code>
  part, to use different subsets of the data in different univariate
  models. For instance, if <code>sub</code> is a logical variable and
  <code>y</code> is the response of one of the univariate models, we may
  write <code>y | subset(sub) ~ predictors</code> so that <code>y</code> is
  predicted only for those observations for which <code>sub</code> evaluates
  to <code>TRUE</code>.</p>
<p>For log-linear models such as poisson models, <code>rate</code> may be used
  in the <code>aterms</code> part to specify the denominator of a response that
  is expressed as a rate. The numerator is given by the actual response
  variable and has a distribution according to the family as usual. Using
  <code>rate(denom)</code> is equivalent to adding <code>offset(log(denom))</code> to
  the linear predictor of the main parameter but the former is arguably
  more convenient and explicit.</p>
<p>With the exception of categorical and ordinal families,
  left, right, and interval censoring can be modeled through
  <code>y | cens(censored) ~ predictors</code>. The censoring variable
  (named <code>censored</code> in this example) should contain the values
  <code>'left'</code>, <code>'none'</code>, <code>'right'</code>, and <code>'interval'</code>
  (or equivalently <code>-1</code>, <code>0</code>, <code>1</code>, and <code>2</code>) to indicate that
  the corresponding observation is left censored, not censored, right censored,
  or interval censored. For interval censored data, a second variable
  (let's call it <code>y2</code>) has to be passed to <code>cens</code>. In this case,
  the formula has the structure <code>y | cens(censored, y2) ~ predictors</code>.
  While the lower bounds are given in <code>y</code>, the upper bounds are given
  in <code>y2</code> for interval censored data. Intervals are assumed to be open
  on the left and closed on the right: <code>(y, y2]</code>.</p>
<p>With the exception of categorical and ordinal families,
  the response distribution can be truncated using the <code>trunc</code>
  function in the addition part. If the response variable is truncated
  between, say, 0 and 100, we can specify this via
  <code>yi | trunc(lb = 0, ub = 100) ~ predictors</code>.
  Instead of numbers, variables in the data set can also be passed allowing
  for varying truncation points across observations. Defining only one of
  the two arguments in <code>trunc</code> leads to one-sided truncation.</p>
<p>For all continuous families, missing values in the responses can be imputed
  within Stan by using the addition term <code>mi</code>. This is mostly
  useful in combination with <code>mi</code> predictor terms as explained
  above under 'Special predictor terms'.</p>
<p>For families <code>binomial</code> and <code>zero_inflated_binomial</code>,
  addition should contain a variable indicating the number of trials
  underlying each observation. In <code>lme4</code> syntax, we may write for instance
  <code>cbind(success, n - success)</code>, which is equivalent
  to <code>success | trials(n)</code> in <span class="pkg">brms</span> syntax. If the number of trials
  is constant across all observations, say <code>10</code>,
  we may also write <code>success | trials(10)</code>.
  <b>Please note that the <code><a href="https://amices.org/mice/reference/cbind.html" class="external-link">cbind()</a></code> syntax will not work
  in <span class="pkg">brms</span> in the expected way because this syntax is reserved
  for other purposes.</b></p>
<p>For all ordinal families, <code>aterms</code> may contain a term
  <code>thres(number)</code> to specify the number thresholds (e.g,
  <code>thres(6)</code>), which should be equal to the total number of response
  categories - 1. If not given, the number of thresholds is calculated from
  the data. If different threshold vectors should be used for different
  subsets of the data, the <code>gr</code> argument can be used to provide the
  grouping variable (e.g, <code>thres(6, gr = item)</code>, if <code>item</code> is the
  grouping variable). In this case, the number of thresholds can also be a
  variable in the data with different values per group.</p>
<p>A deprecated quasi alias of <code><a href="addition-terms.html">thres()</a></code> is <code><a href="addition-terms.html">cat()</a></code> with which the
  total number of response categories (i.e., number of thresholds + 1) can be
  specified.</p>
<p>In Wiener diffusion models (family <code>wiener</code>) the addition term
  <code>dec</code> is mandatory to specify the (vector of) binary decisions
  corresponding to the reaction times. Non-zero values will be treated
  as a response on the upper boundary of the diffusion process and zeros
  will be treated as a response on the lower boundary. Alternatively,
  the variable passed to <code>dec</code> might also be a character vector
  consisting of <code>'lower'</code> and <code>'upper'</code>.</p>
<p>All families support the <code>index</code> addition term to uniquely identify
  each observation of the corresponding response variable. Currently,
  <code>index</code> is primarily useful in combination with the <code>subset</code>
  addition and <code><a href="mi.html">mi</a></code> terms.</p>
<p>For custom families, it is possible to pass an arbitrary number of real and
  integer vectors via the addition terms <code>vreal</code> and <code>vint</code>,
  respectively. An example is provided in
  <code><a href="../articles/brms_customfamilies.html">vignette('brms_customfamilies')</a></code>. To pass multiple vectors of the
  same data type, provide them separated by commas inside a single
  <code>vreal</code> or <code>vint</code> statement.</p>
<p>Multiple addition terms of different types may be specified at the same
  time using the <code>+</code> operator. For example, the formula
  <code>formula = yi | se(sei) + cens(censored) ~ 1</code> implies a censored
  meta-analytic model.</p>
<p>The addition argument <code>disp</code> (short for dispersion)
  has been removed in version 2.0. You may instead use the
  distributional regression approach by specifying
  <code>sigma ~ 1 + offset(log(xdisp))</code> or
  <code>shape ~ 1 + offset(log(xdisp))</code>, where <code>xdisp</code> is
  the variable being previously passed to <code>disp</code>.</p>
<p><b>Parameterization of the population-level intercept</b></p>
<p>By default, the population-level intercept (if incorporated) is estimated
  separately and not as part of population-level parameter vector <code>b</code> As
  a result, priors on the intercept also have to be specified separately.
  Furthermore, to increase sampling efficiency, the population-level design
  matrix <code>X</code> is centered around its column means <code>X_means</code> if the
  intercept is incorporated. This leads to a temporary bias in the intercept
  equal to <code>&lt;X_means, b&gt;</code>, where <code>&lt;,&gt;</code> is the scalar product. The
  bias is corrected after fitting the model, but be aware that you are
  effectively defining a prior on the intercept of the centered design matrix
  not on the real intercept. You can turn off this special handling of the
  intercept by setting argument <code>center</code> to <code>FALSE</code>. For more
  details on setting priors on population-level intercepts, see
  <code><a href="set_prior.html">set_prior</a></code>.</p>
<p>This behavior can be avoided by using the reserved
  (and internally generated) variable <code>Intercept</code>.
  Instead of <code>y ~ x</code>, you may write
  <code>y ~ 0 + Intercept + x</code>. This way, priors can be
  defined on the real intercept, directly. In addition,
  the intercept is just treated as an ordinary population-level effect
  and thus priors defined on <code>b</code> will also apply to it.
  Note that this parameterization may be less efficient
  than the default parameterization discussed above.</p>
<p><b>Formula syntax for non-linear models</b></p>
<p>In <span class="pkg">brms</span>, it is possible to specify non-linear models
  of arbitrary complexity.
  The non-linear model can just be specified within the <code>formula</code>
  argument. Suppose, that we want to predict the response <code>y</code>
  through the predictor <code>x</code>, where <code>x</code> is linked to <code>y</code>
  through <code>y = alpha - beta * lambda^x</code>, with parameters
  <code>alpha</code>, <code>beta</code>, and <code>lambda</code>. This is certainly a
  non-linear model being defined via
  <code>formula = y ~ alpha - beta * lambda^x</code> (addition arguments
  can be added in the same way as for ordinary formulas).
  To tell <span class="pkg">brms</span> that this is a non-linear model,
  we set argument <code>nl</code> to <code>TRUE</code>.
  Now we have to specify a model for each of the non-linear parameters.
  Let's say we just want to estimate those three parameters
  with no further covariates or random effects. Then we can pass
  <code>alpha + beta + lambda ~ 1</code> or equivalently
  (and more flexible) <code>alpha ~ 1, beta ~ 1, lambda ~ 1</code>
  to the <code>...</code> argument.
  This can, of course, be extended. If we have another predictor <code>z</code> and
  observations nested within the grouping factor <code>g</code>, we may write for
  instance <code>alpha ~ 1, beta ~ 1 + z + (1|g), lambda ~ 1</code>.
  The formula syntax described above applies here as well.
  In this example, we are using <code>z</code> and <code>g</code> only for the
  prediction of <code>beta</code>, but we might also use them for the other
  non-linear parameters (provided that the resulting model is still
  scientifically reasonable).</p>
<p>By default, non-linear covariates are treated as real vectors in Stan.
  However, if the data of the covariates is of type `integer` in <span style="R">R</span> (which
  can be enforced by the `as.integer` function), the Stan type will be
  changed to an integer array. That way, covariates can also be used
  for indexing purposes in Stan.</p>
<p>Non-linear models may not be uniquely identified and / or show bad convergence.
  For this reason it is mandatory to specify priors on the non-linear parameters.
  For instructions on how to do that, see <code><a href="set_prior.html">set_prior</a></code>.
  For some examples of non-linear models, see <code><a href="../articles/brms_nonlinear.html">vignette("brms_nonlinear")</a></code>.</p>
<p><b>Formula syntax for predicting distributional parameters</b></p>
<p>It is also possible to predict parameters of the response distribution such
  as the residual standard deviation <code>sigma</code> in gaussian models or the
  hurdle probability <code>hu</code> in hurdle models. The syntax closely resembles
  that of a non-linear parameter, for instance <code>sigma ~ x + s(z) +
  (1+x|g)</code>. For some examples of distributional models, see
  <code><a href="../articles/brms_distreg.html">vignette("brms_distreg")</a></code>.</p>
<p>Parameter <code>mu</code> exists for every family and can be used as an
  alternative to specifying terms in <code>formula</code>. If both <code>mu</code> and
  <code>formula</code> are given, the right-hand side of <code>formula</code> is ignored.
  Accordingly, specifying terms on the right-hand side of both <code>formula</code>
  and <code>mu</code> at the same time is deprecated. In future versions,
  <code>formula</code> might be updated by <code>mu</code>.</p>
<p>The following are
  distributional parameters of specific families (all other parameters are
  treated as non-linear parameters): <code>sigma</code> (residual standard
  deviation or scale of the <code>gaussian</code>, <code>student</code>,
  <code>skew_normal</code>, <code>lognormal</code> <code>exgaussian</code>, and
  <code>asym_laplace</code> families); <code>shape</code> (shape parameter of the
  <code>Gamma</code>, <code>weibull</code>, <code>negbinomial</code>, and related zero-inflated
  / hurdle families); <code>nu</code> (degrees of freedom parameter of the
  <code>student</code> and <code>frechet</code> families); <code>phi</code> (precision
  parameter of the <code>beta</code> and <code>zero_inflated_beta</code> families);
  <code>kappa</code> (precision parameter of the <code>von_mises</code> family);
  <code>beta</code> (mean parameter of the exponential component of the
  <code>exgaussian</code> family); <code>quantile</code> (quantile parameter of the
  <code>asym_laplace</code> family); <code>zi</code> (zero-inflation probability);
  <code>hu</code> (hurdle probability); <code>zoi</code> (zero-one-inflation
  probability); <code>coi</code> (conditional one-inflation probability);
  <code>disc</code> (discrimination) for ordinal models; <code>bs</code>, <code>ndt</code>, and
  <code>bias</code> (boundary separation, non-decision time, and initial bias of
  the <code>wiener</code> diffusion model). By default, distributional parameters
  are modeled on the log scale if they can be positive only or on the logit
  scale if the can only be within the unit interval.</p>
<p>Alternatively, one may fix distributional parameters to certain values.
  However, this is mainly useful when models become too
  complicated and otherwise have convergence issues.
  We thus suggest to be generally careful when making use of this option.
  The <code>quantile</code> parameter of the <code>asym_laplace</code> distribution
  is a good example where it is useful. By fixing <code>quantile</code>,
  one can perform quantile regression for the specified quantile.
  For instance, <code>quantile = 0.25</code> allows predicting the 25%-quantile.
  Furthermore, the <code>bias</code> parameter in drift-diffusion models,
  is assumed to be <code>0.5</code> (i.e. no bias) in many applications.
  To achieve this, simply write <code>bias = 0.5</code>.
  Other possible applications are the Cauchy distribution as a
  special case of the Student-t distribution with
  <code>nu = 1</code>, or the geometric distribution as a special case of
  the negative binomial distribution with <code>shape = 1</code>.
  Furthermore, the parameter <code>disc</code> ('discrimination') in ordinal
  models is fixed to <code>1</code> by default and not estimated,
  but may be modeled as any other distributional parameter if desired
  (see examples). For reasons of identification, <code>'disc'</code>
  can only be positive, which is achieved by applying the log-link.</p>
<p>In categorical models, distributional parameters do not have
  fixed names. Instead, they are named after the response categories
  (excluding the first one, which serves as the reference category),
  with the prefix <code>'mu'</code>. If, for instance, categories are named
  <code>cat1</code>, <code>cat2</code>, and <code>cat3</code>, the distributional parameters
  will be named <code>mucat2</code> and <code>mucat3</code>.</p>
<p>Some distributional parameters currently supported by <code>brmsformula</code>
  have to be positive (a negative standard deviation or precision parameter
  does not make any sense) or are bounded between 0 and 1 (for zero-inflated /
  hurdle probabilities, quantiles, or the initial bias parameter of
  drift-diffusion models).
  However, linear predictors can be positive or negative, and thus the log link
  (for positive parameters) or logit link (for probability parameters) are used
  by default to ensure that distributional parameters are within their valid intervals.
  This implies that, by default, effects for such distributional parameters are
  estimated on the log / logit scale and one has to apply the inverse link
  function to get to the effects on the original scale.
  Alternatively, it is possible to use the identity link to predict parameters
  on their original scale, directly. However, this is much more likely to lead
  to problems in the model fitting, if the parameter actually has a restricted range.</p>
<p>See also <code><a href="brmsfamily.html">brmsfamily</a></code> for an overview of valid link functions.</p>
<p><b>Formula syntax for mixture models</b></p>
<p>The specification of mixture models closely resembles that
  of non-mixture models. If not specified otherwise (see below),
  all mean parameters of the mixture components are predicted
  using the right-hand side of <code>formula</code>. All types of predictor
  terms allowed in non-mixture models are allowed in mixture models
  as well.</p>
<p>Distributional parameters of mixture distributions have the same
  name as those of the corresponding ordinary distributions, but with
  a number at the end to indicate the mixture component. For instance, if
  you use family <code>mixture(gaussian, gaussian)</code>, the distributional
  parameters are <code>sigma1</code> and <code>sigma2</code>.
  Distributional parameters of the same class can be fixed to the same value.
  For the above example, we could write <code>sigma2 = "sigma1"</code> to make
  sure that both components have the same residual standard deviation,
  which is in turn estimated from the data.</p>
<p>In addition, there are two types of special distributional parameters.
  The first are named <code>mu&lt;ID&gt;</code>, that allow for modeling different
  predictors for the mean parameters of different mixture components.
  For instance, if you want to predict the mean of the first component
  using predictor <code>x</code> and the mean of the second component using
  predictor <code>z</code>, you can write <code>mu1 ~ x</code> as well as <code>mu2 ~ z</code>.
  The second are named <code>theta&lt;ID&gt;</code>, which constitute the mixing
  proportions. If the mixing proportions are fixed to certain values,
  they are internally normalized to form a probability vector.
  If one seeks to predict the mixing proportions, all but
  one of the them has to be predicted, while the remaining one is used
  as the reference category to identify the model. The so-called 'softmax'
  transformation is applied on the linear predictor terms to form a
  probability vector.</p>
<p>For more information on mixture models, see
  the documentation of <code><a href="mixture.html">mixture</a></code>.</p>
<p><b>Formula syntax for multivariate models</b></p>
<p>Multivariate models may be specified using <code>mvbind</code> notation
  or with help of the <code><a href="mvbrmsformula.html">mvbf</a></code> function.
  Suppose that <code>y1</code> and <code>y2</code> are response variables
  and <code>x</code> is a predictor. Then <code>mvbind(y1, y2) ~ x</code>
  specifies a multivariate model.
  The effects of all terms specified at the RHS of the formula
  are assumed to vary across response variables.
  For instance, two parameters will be estimated for <code>x</code>,
  one for the effect on <code>y1</code> and another for the effect on <code>y2</code>.
  This is also true for group-level effects. When writing, for instance,
  <code>mvbind(y1, y2) ~ x + (1+x|g)</code>, group-level effects will be
  estimated separately for each response. To model these effects
  as correlated across responses, use the ID syntax (see above).
  For the present example, this would look as follows:
  <code>mvbind(y1, y2) ~ x + (1+x|2|g)</code>. Of course, you could also use
  any value other than <code>2</code> as ID.</p>
<p>It is also possible to specify different formulas for different responses.
  If, for instance, <code>y1</code> should be predicted by <code>x</code> and <code>y2</code>
  should be predicted by <code>z</code>, we could write <code>mvbf(y1 ~ x, y2 ~ z)</code>.
  Alternatively, multiple <code>brmsformula</code> objects can be added to
  specify a joint multivariate model (see 'Examples').</p>
    </div>
    <div id="see-also">
    <h2>See also</h2>
    <div class="dont-index"><p><code><a href="mvbrmsformula.html">mvbrmsformula</a></code>, <code><a href="brmsformula-helpers.html">brmsformula-helpers</a></code></p></div>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># multilevel model with smoothing terms</span></span></span>
<span class="r-in"><span><span class="fu">brmsformula</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">x1</span><span class="op">*</span><span class="va">x2</span> <span class="op">+</span> <span class="fu"><a href="s.html">s</a></span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="va">x1</span><span class="op">|</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">g2</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ x1 * x2 + s(z) + (1 + x1 | 1) + (1 | g2) </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># additionally predict 'sigma'</span></span></span>
<span class="r-in"><span><span class="fu">brmsformula</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">x1</span><span class="op">*</span><span class="va">x2</span> <span class="op">+</span> <span class="fu"><a href="s.html">s</a></span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="va">x1</span><span class="op">|</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">g2</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            <span class="va">sigma</span> <span class="op">~</span> <span class="va">x1</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">g2</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ x1 * x2 + s(z) + (1 + x1 | 1) + (1 | g2) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sigma ~ x1 + (1 | g2)</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># use the shorter alias 'bf'</span></span></span>
<span class="r-in"><span><span class="op">(</span><span class="va">formula1</span> <span class="op">&lt;-</span> <span class="fu">brmsformula</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">x</span> <span class="op">+</span> <span class="op">(</span><span class="va">x</span><span class="op">|</span><span class="va">g</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ x + (x | g) </span>
<span class="r-in"><span><span class="op">(</span><span class="va">formula2</span> <span class="op">&lt;-</span> <span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">x</span> <span class="op">+</span> <span class="op">(</span><span class="va">x</span><span class="op">|</span><span class="va">g</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ x + (x | g) </span>
<span class="r-in"><span><span class="co"># will be TRUE</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/identical.html" class="external-link">identical</a></span><span class="op">(</span><span class="va">formula1</span>, <span class="va">formula2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># incorporate censoring</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">|</span> <span class="fu"><a href="addition-terms.html">cens</a></span><span class="op">(</span><span class="va">censor_variable</span><span class="op">)</span> <span class="op">~</span> <span class="va">predictors</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y | cens(censor_variable) ~ predictors </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># define a simple non-linear model</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">a1</span> <span class="op">-</span> <span class="va">a2</span><span class="op">^</span><span class="va">x</span>, <span class="va">a1</span> <span class="op">+</span> <span class="va">a2</span> <span class="op">~</span> <span class="fl">1</span>, nl <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ a1 - a2^x </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a1 ~ 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a2 ~ 1</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># predict a1 and a2 differently</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">a1</span> <span class="op">-</span> <span class="va">a2</span><span class="op">^</span><span class="va">x</span>, <span class="va">a1</span> <span class="op">~</span> <span class="fl">1</span>, <span class="va">a2</span> <span class="op">~</span> <span class="va">x</span> <span class="op">+</span> <span class="op">(</span><span class="va">x</span><span class="op">|</span><span class="va">g</span><span class="op">)</span>, nl <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ a1 - a2^x </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a1 ~ 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a2 ~ x + (x | g)</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># correlated group-level effects across parameters</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">a1</span> <span class="op">-</span> <span class="va">a2</span><span class="op">^</span><span class="va">x</span>, <span class="va">a1</span> <span class="op">~</span> <span class="fl">1</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span> <span class="op">|</span><span class="fl">2</span><span class="op">|</span> <span class="va">g</span><span class="op">)</span>, <span class="va">a2</span> <span class="op">~</span> <span class="va">x</span> <span class="op">+</span> <span class="op">(</span><span class="va">x</span> <span class="op">|</span><span class="fl">2</span><span class="op">|</span> <span class="va">g</span><span class="op">)</span>, nl <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ a1 - a2^x </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a1 ~ 1 + (1 | 2 | g)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a2 ~ x + (x | 2 | g)</span>
<span class="r-in"><span><span class="co"># alternative but equivalent way to specify the above model</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">a1</span> <span class="op">-</span> <span class="va">a2</span><span class="op">^</span><span class="va">x</span>, <span class="va">a1</span> <span class="op">~</span> <span class="fl">1</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span> <span class="op">|</span> <span class="fu"><a href="gr.html">gr</a></span><span class="op">(</span><span class="va">g</span>, id <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>   <span class="va">a2</span> <span class="op">~</span> <span class="va">x</span> <span class="op">+</span> <span class="op">(</span><span class="va">x</span> <span class="op">|</span> <span class="fu"><a href="gr.html">gr</a></span><span class="op">(</span><span class="va">g</span>, id <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span>, nl <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ a1 - a2^x </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a1 ~ 1 + (1 | gr(g, id = 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a2 ~ x + (x | gr(g, id = 2))</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># define a multivariate model</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="fu"><a href="mvbind.html">mvbind</a></span><span class="op">(</span><span class="va">y1</span>, <span class="va">y2</span><span class="op">)</span> <span class="op">~</span> <span class="va">x</span> <span class="op">*</span> <span class="va">z</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">g</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y1 ~ x * z + (1 | g) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y2 ~ x * z + (1 | g) </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># define a zero-inflated model</span></span></span>
<span class="r-in"><span><span class="co"># also predicting the zero-inflation part</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">x</span> <span class="op">*</span> <span class="va">z</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="va">x</span><span class="op">|</span><span class="va">ID1</span><span class="op">|</span><span class="va">g</span><span class="op">)</span>, <span class="va">zi</span> <span class="op">~</span> <span class="va">x</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">ID1</span><span class="op">|</span><span class="va">g</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ x * z + (1 + x | ID1 | g) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> zi ~ x + (1 | ID1 | g)</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># specify a predictor as monotonic</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="mo.html">mo</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">+</span> <span class="va">more_predictors</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ mo(x) + more_predictors </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># for ordinal models only</span></span></span>
<span class="r-in"><span><span class="co"># specify a predictor as category specific</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="cs.html">cs</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">+</span> <span class="va">more_predictors</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ cs(x) + more_predictors </span>
<span class="r-in"><span><span class="co"># add a category specific group-level intercept</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="cs.html">cs</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="fu"><a href="cs.html">cs</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">|</span><span class="va">g</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ cs(x) + (cs(1) | g) </span>
<span class="r-in"><span><span class="co"># specify parameter 'disc'</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">person</span> <span class="op">+</span> <span class="va">item</span>, <span class="va">disc</span> <span class="op">~</span> <span class="va">item</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ person + item </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> disc ~ item</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># specify variables containing measurement error</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="me.html">me</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">sdx</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ me(x, sdx) </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># specify predictors on all parameters of the wiener diffusion model</span></span></span>
<span class="r-in"><span><span class="co"># the main formula models the drift rate 'delta'</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">rt</span> <span class="op">|</span> <span class="fu"><a href="addition-terms.html">dec</a></span><span class="op">(</span><span class="va">decision</span><span class="op">)</span> <span class="op">~</span> <span class="va">x</span>, <span class="va">bs</span> <span class="op">~</span> <span class="va">x</span>, <span class="va">ndt</span> <span class="op">~</span> <span class="va">x</span>, <span class="va">bias</span> <span class="op">~</span> <span class="va">x</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rt | dec(decision) ~ x </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bs ~ x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ndt ~ x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bias ~ x</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># fix the bias parameter to 0.5</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">rt</span> <span class="op">|</span> <span class="fu"><a href="addition-terms.html">dec</a></span><span class="op">(</span><span class="va">decision</span><span class="op">)</span> <span class="op">~</span> <span class="va">x</span>, bias <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rt | dec(decision) ~ x </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bias = 0.5</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># specify different predictors for different mixture components</span></span></span>
<span class="r-in"><span><span class="va">mix</span> <span class="op">&lt;-</span> <span class="fu"><a href="mixture.html">mixture</a></span><span class="op">(</span><span class="va">gaussian</span>, <span class="va">gaussian</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Setting order = 'mu' for mixtures of the same family.</span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fl">1</span>, <span class="va">mu1</span> <span class="op">~</span> <span class="va">x</span>, <span class="va">mu2</span> <span class="op">~</span> <span class="va">z</span>, family <span class="op">=</span> <span class="va">mix</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mu1 ~ x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mu2 ~ z</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># fix both residual standard deviations to the same value</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">x</span>, sigma2 <span class="op">=</span> <span class="st">"sigma1"</span>, family <span class="op">=</span> <span class="va">mix</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ x </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sigma2 = sigma1</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># use the '+' operator to specify models</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="brmsformula-helpers.html">nlf</a></span><span class="op">(</span><span class="va">sigma</span> <span class="op">~</span> <span class="va">a</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">b</span> <span class="op">*</span> <span class="va">x</span><span class="op">)</span>, <span class="va">a</span> <span class="op">~</span> <span class="va">x</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="brmsformula-helpers.html">lf</a></span><span class="op">(</span><span class="va">b</span> <span class="op">~</span> <span class="va">z</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">g</span><span class="op">)</span>, dpar <span class="op">=</span> <span class="st">"sigma"</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>Arguments '...' and 'flist' in nlf() will be reworked at some point. Please avoid using them if possible.</span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>Argument 'dpar' is no longer necessary and ignored.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ 1 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sigma ~ a * exp(b * x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> a ~ x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> b ~ z + (1 | g)</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># specify a multivariate model using the '+' operator</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y1</span> <span class="op">~</span> <span class="va">x</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">g</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="cor_ar.html">cor_ar</a></span><span class="op">(</span><span class="op">~</span><span class="fl">1</span><span class="op">|</span><span class="va">g</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu">bf</span><span class="op">(</span><span class="va">y2</span> <span class="op">~</span> <span class="va">z</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>Using 'cor_brms' objects for 'autocor' is deprecated. Please see ?cor_brms for details.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y1 ~ x + (1 | g) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> autocor ~ arma(time = NA, gr = g, p = 1, q = 0, cov = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y2 ~ z </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># specify correlated residuals of a gaussian and a poisson model</span></span></span>
<span class="r-in"><span><span class="va">form1</span> <span class="op">&lt;-</span> <span class="fu">bf</span><span class="op">(</span><span class="va">y1</span> <span class="op">~</span> <span class="fl">1</span> <span class="op">+</span> <span class="va">x</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">c</span><span class="op">|</span><span class="va">obs</span><span class="op">)</span>, sigma <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">form2</span> <span class="op">&lt;-</span> <span class="fu">bf</span><span class="op">(</span><span class="va">y2</span> <span class="op">~</span> <span class="fl">1</span> <span class="op">+</span> <span class="va">x</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">c</span><span class="op">|</span><span class="va">obs</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># model missing values in predictors</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">bmi</span> <span class="op">~</span> <span class="va">age</span> <span class="op">*</span> <span class="fu"><a href="mi.html">mi</a></span><span class="op">(</span><span class="va">chl</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu">bf</span><span class="op">(</span><span class="va">chl</span> <span class="op">|</span> <span class="fu"><a href="mi.html">mi</a></span><span class="op">(</span><span class="op">)</span> <span class="op">~</span> <span class="va">age</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="brmsformula-helpers.html">set_rescor</a></span><span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bmi ~ age * mi(chl) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> chl | mi() ~ age </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># model sigma as a function of the mean</span></span></span>
<span class="r-in"><span><span class="fu">bf</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">eta</span>, nl <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="brmsformula-helpers.html">lf</a></span><span class="op">(</span><span class="va">eta</span> <span class="op">~</span> <span class="fl">1</span> <span class="op">+</span> <span class="va">x</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="brmsformula-helpers.html">nlf</a></span><span class="op">(</span><span class="va">sigma</span> <span class="op">~</span> <span class="va">tau</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">eta</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="brmsformula-helpers.html">lf</a></span><span class="op">(</span><span class="va">tau</span> <span class="op">~</span> <span class="fl">1</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y ~ eta </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> eta ~ 1 + x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sigma ~ tau * sqrt(eta)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tau ~ 1</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Paul-Christian Bürkner.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

      </footer></div>






  </body></html>

