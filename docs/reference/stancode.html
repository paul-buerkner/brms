<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Stan Code for Bayesian models — stancode • brms</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Stan Code for Bayesian models — stancode"><meta name="description" content="stancode is a generic function that can be used to
  generate Stan code for Bayesian models. Its original use is
  within the brms package, but new methods for use
  with objects from other packages can be registered to the same generic."><meta property="og:description" content="stancode is a generic function that can be used to
  generate Stan code for Bayesian models. Its original use is
  within the brms package, but new methods for use
  with objects from other packages can be registered to the same generic."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">brms</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.22.12</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/brms_customfamilies.html">Define Custom Response Distributions with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_distreg.html">Estimating Distributional Models with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_families.html">Parameterization of Response Distributions in brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_missings.html">Handle Missing Values with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_monotonic.html">Estimating Monotonic Effects with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_multivariate.html">Estimating Multivariate Models with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_nonlinear.html">Estimating Non-Linear Models with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_phylogenetics.html">Estimating Phylogenetic Multilevel Models with brms</a></li>
    <li><a class="dropdown-item" href="../articles/brms_threading.html">Running brms models with within-chain parallelization</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/paul-buerkner/brms/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Stan Code for Bayesian models</h1>
      <small class="dont-index">Source: <a href="https://github.com/paul-buerkner/brms/blob/HEAD/R/stancode.R" class="external-link"><code>R/stancode.R</code></a></small>
      <div class="d-none name"><code>stancode.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><code>stancode</code> is a generic function that can be used to
  generate Stan code for Bayesian models. Its original use is
  within the <span class="pkg">brms</span> package, but new methods for use
  with objects from other packages can be registered to the same generic.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">stancode</span><span class="op">(</span><span class="va">object</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">make_stancode</span><span class="op">(</span><span class="va">formula</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-object">object<a class="anchor" aria-label="anchor" href="#arg-object"></a></dt>
<dd><p>An object whose class will determine which method to apply.
Usually, it will be some kind of symbolic description of the model
form which Stan code should be generated.</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>Further arguments passed to the specific method.</p></dd>


<dt id="arg-formula">formula<a class="anchor" aria-label="anchor" href="#arg-formula"></a></dt>
<dd><p>Synonym of <code>object</code> for use in <code>make_stancode</code>.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>Usually, a character string containing the generated Stan code.
  For pretty printing, we recommend the returned object to be of class
  <code>c("character", "brmsmodel")</code>.</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>See <code><a href="stancode.default.html">stancode.default</a></code> for the default
  method applied for <span class="pkg">brms</span> models.
  You can view the available methods by typing: <code>methods(stancode)</code>
  The <code>make_stancode</code> function is an alias of <code>stancode</code>.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="stancode.default.html">stancode.default</a></code>, <code><a href="stancode.brmsfit.html">stancode.brmsfit</a></code></p></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="fu">stancode</span><span class="op">(</span><span class="va">rating</span> <span class="op">~</span> <span class="va">treat</span> <span class="op">+</span> <span class="va">period</span> <span class="op">+</span> <span class="va">carry</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">subject</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>         data <span class="op">=</span> <span class="va">inhaler</span>, family <span class="op">=</span> <span class="st">"cumulative"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // generated with brms 2.22.12</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   /* cumulative-logit log-PDF for a single response</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Args:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   y: response category</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   mu: latent mean parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   disc: discrimination parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   thres: ordinal thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Returns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   a scalar to be added to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    */</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    real cumulative_logit_lpmf(int y, real mu, real disc, vector thres) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      int nthres = num_elements(thres);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      if (y == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        return log_inv_logit(disc * (thres[1] - mu));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      } else if (y == nthres + 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        return log1m_inv_logit(disc * (thres[nthres] - mu));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        return log_inv_logit_diff(disc * (thres[y] - mu), disc * (thres[y - 1] - mu));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   /* cumulative-logit log-PDF for a single response and merged thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Args:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   y: response category</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   mu: latent mean parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   disc: discrimination parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   thres: vector of merged ordinal thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   j: start and end index for the applid threshold within 'thres'</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Returns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   a scalar to be added to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    */</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    real cumulative_logit_merged_lpmf(int y, real mu, real disc, vector thres, array[] int j) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      return cumulative_logit_lpmf(y | mu, disc, thres[j[1]:j[2]]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   /* ordered-logistic log-PDF for a single response and merged thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Args:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   y: response category</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   mu: latent mean parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   thres: vector of merged ordinal thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   j: start and end index for the applid threshold within 'thres'</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Returns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   a scalar to be added to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    */</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    real ordered_logistic_merged_lpmf(int y, real mu, vector thres, array[] int j) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      return ordered_logistic_lpmf(y | mu, thres[j[1]:j[2]]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N;  // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N] int Y;  // response variable</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=2&gt; nthres;  // number of thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; K;  // number of population-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, K] X;  // population-level design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; Kc;  // number of population-level effects after centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // data for group-level effects of ID 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N_1;  // number of grouping levels</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; M_1;  // number of coefficients per level</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N] int&lt;lower=1&gt; J_1;  // grouping indicator per observation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // group-level predictor values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[N] Z_1_1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int prior_only;  // should the likelihood be ignored?</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, Kc] Xc;  // centered version of X</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] means_X;  // column means of X before centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     means_X[i] = mean(X[, i]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     Xc[, i] = X[, i] - means_X[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] b;  // regression coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ordered[nthres] Intercept;  // temporary thresholds for centered predictors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[M_1] sd_1;  // group-level standard deviations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[M_1] vector[N_1] z_1;  // standardized group-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real disc = 1;  // discrimination parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[N_1] r_1_1;  // actual group-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior contributions to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real lprior = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   r_1_1 = (sd_1[1] * (z_1[1]));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += student_t_lpdf(Intercept | 3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += student_t_lpdf(sd_1 | 3, 0, 2.5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     - 1 * student_t_lccdf(0 | 3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // likelihood including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!prior_only) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // initialize linear predictor term</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N] mu = rep_vector(0.0, N);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mu += Xc * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1:N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       // add more terms to the linear predictor</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       mu[n] += r_1_1[J_1[n]] * Z_1_1[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1:N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += ordered_logistic_lpmf(Y[n] | mu[n], Intercept);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += lprior;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += std_normal_lpdf(z_1[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // compute actual thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nthres] b_Intercept = Intercept + dot_product(means_X, b);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Paul-Christian Bürkner.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer></div>





  </body></html>

