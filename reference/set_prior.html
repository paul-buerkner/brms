<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Prior Definitions for brms Models — set_prior • brms</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Prior Definitions for brms Models — set_prior"><meta property="og:description" content="Define priors for specific parameters or classes of parameters."><meta property="og:image" content="/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">brms</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">2.22.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../articles/index.html">Vignettes</a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Other Packages
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="http://mc-stan.org/rstan" class="external-link">rstan</a>
    </li>
    <li>
      <a href="http://mc-stan.org/rstanarm" class="external-link">rstanarm</a>
    </li>
    <li>
      <a href="http://mc-stan.org/bayesplot" class="external-link">bayesplot</a>
    </li>
    <li>
      <a href="http://mc-stan.org/shinystan" class="external-link">shinystan</a>
    </li>
    <li>
      <a href="http://mc-stan.org/loo" class="external-link">loo</a>
    </li>
    <li>
      <a href="http://mc-stan.org/projpred" class="external-link">projpred</a>
    </li>
    <li>
      <a href="http://mc-stan.org/rstantools" class="external-link">rstantools</a>
    </li>
  </ul></li>
<li>
  <a href="http://mc-stan.org" class="external-link">Stan</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://twitter.com/mcmc_stan" class="external-link">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/paul-buerkner/brms" class="external-link">
    <span class="fa fa-github"></span>
     
  </a>
</li>
<li>
  <a href="http://discourse.mc-stan.org/" class="external-link">
    <span class="fa fa-users"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Prior Definitions for <span class="pkg">brms</span> Models</h1>
    <small class="dont-index">Source: <a href="https://github.com/paul-buerkner/brms/blob/HEAD/R/priors.R" class="external-link"><code>R/priors.R</code></a></small>
    <div class="hidden name"><code>set_prior.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Define priors for specific parameters or classes of parameters.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">set_prior</span><span class="op">(</span></span>
<span>  <span class="va">prior</span>,</span>
<span>  class <span class="op">=</span> <span class="st">"b"</span>,</span>
<span>  coef <span class="op">=</span> <span class="st">""</span>,</span>
<span>  group <span class="op">=</span> <span class="st">""</span>,</span>
<span>  resp <span class="op">=</span> <span class="st">""</span>,</span>
<span>  dpar <span class="op">=</span> <span class="st">""</span>,</span>
<span>  nlpar <span class="op">=</span> <span class="st">""</span>,</span>
<span>  lb <span class="op">=</span> <span class="cn">NA</span>,</span>
<span>  ub <span class="op">=</span> <span class="cn">NA</span>,</span>
<span>  check <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">prior</span><span class="op">(</span><span class="va">prior</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">prior_</span><span class="op">(</span><span class="va">prior</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">prior_string</span><span class="op">(</span><span class="va">prior</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">empty_prior</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>prior</dt>
<dd><p>A character string defining a distribution in <span class="pkg">Stan</span> language</p></dd>


<dt>class</dt>
<dd><p>The parameter class. Defaults to <code>"b"</code>
(i.e. population-level effects).
See 'Details' for other valid parameter classes.</p></dd>


<dt>coef</dt>
<dd><p>Name of the coefficient within the parameter class.</p></dd>


<dt>group</dt>
<dd><p>Grouping factor for group-level parameters.</p></dd>


<dt>resp</dt>
<dd><p>Name of the response variable.
Only used in multivariate models.</p></dd>


<dt>dpar</dt>
<dd><p>Name of a distributional parameter.
Only used in distributional models.</p></dd>


<dt>nlpar</dt>
<dd><p>Name of a non-linear parameter.
Only used in non-linear models.</p></dd>


<dt>lb</dt>
<dd><p>Lower bound for parameter restriction. Currently only allowed
for classes <code>"b"</code>. Defaults to <code>NULL</code>, that is no restriction.</p></dd>


<dt>ub</dt>
<dd><p>Upper bound for parameter restriction. Currently only allowed
for classes <code>"b"</code>. Defaults to <code>NULL</code>, that is no restriction.</p></dd>


<dt>check</dt>
<dd><p>Logical; Indicates whether priors
should be checked for validity (as far as possible).
Defaults to <code>TRUE</code>. If <code>FALSE</code>, <code>prior</code> is passed
to the Stan code as is, and all other arguments are ignored.</p></dd>


<dt>...</dt>
<dd><p>Arguments passed to <code>set_prior</code>.</p></dd>

</dl></div>
    <div id="value">
    <h2>Value</h2>
    

<p>An object of class <code>brmsprior</code> to be used in the <code>prior</code></p>


<p>argument of <code><a href="brm.html">brm</a></code>.</p>
    </div>
    <div id="details">
    <h2>Details</h2>
    <p><code>set_prior</code> is used to define prior distributions for parameters
  in <span class="pkg">brms</span> models. The functions <code>prior</code>, <code>prior_</code>, and
  <code>prior_string</code> are aliases of <code>set_prior</code> each allowing
  for a different kind of argument specification.
  <code>prior</code> allows specifying arguments as expression without
  quotation marks using non-standard evaluation.
  <code>prior_</code> allows specifying arguments as one-sided formulas
  or wrapped in <code>quote</code>.
  <code>prior_string</code> allows specifying arguments as strings just
  as <code>set_prior</code> itself.</p>
<p>Below, we explain its usage and list some common
  prior distributions for parameters.
  A complete overview on possible prior distributions is given
  in the Stan Reference Manual available at <a href="https://mc-stan.org/" class="external-link">https://mc-stan.org/</a>.</p>
<p>To combine multiple priors, use <code>c(...)</code> or the <code>+</code> operator
  (see 'Examples'). <span class="pkg">brms</span> does not check if the priors are written
  in correct <span class="pkg">Stan</span> language. Instead, <span class="pkg">Stan</span> will check their
  syntactical correctness when the model is parsed to <code>C++</code> and
  returns an error if they are not.
  This, however, does not imply that priors are always meaningful if they are
  accepted by <span class="pkg">Stan</span>. Although <span class="pkg">brms</span> trys to find common problems
  (e.g., setting bounded priors on unbounded parameters), there is no guarantee
  that the defined priors are reasonable for the model.
  Below, we list the types of parameters in <span class="pkg">brms</span> models,
  for which the user can specify prior distributions.</p>
<p>Below, we provide details for the individual parameter classes that you can
  set priors on. Often, it may not be immediately clear, which parameters are
  present in the model. To get a full list of parameters and parameter
  classes for which priors can be specified (depending on the model) use
  function <code><a href="default_prior.default.html">default_prior</a></code>.</p>
<p>1. Population-level ('fixed') effects</p>
<p>Every Population-level effect has its own regression parameter
  represents the name of the corresponding population-level effect.
  Suppose, for instance, that <code>y</code> is predicted by <code>x1</code> and <code>x2</code>
  (i.e., <code>y ~ x1 + x2</code> in formula syntax).
  Then, <code>x1</code> and <code>x2</code> have regression parameters
  <code>b_x1</code> and <code>b_x2</code> respectively.
  The default prior for population-level effects (including monotonic and
  category specific effects) is an improper flat prior over the reals.
  Other common options are normal priors or student-t priors.
  If we want to have a normal prior with mean 0 and
  standard deviation 5 for <code>x1</code>, and a unit student-t prior with 10
  degrees of freedom for <code>x2</code>, we can specify this via
  <code>set_prior("normal(0,5)", class = "b", coef = "x1")</code> and <br><code>set_prior("student_t(10, 0, 1)", class = "b", coef = "x2")</code>.
  To put the same prior on all population-level effects at once,
  we may write as a shortcut <code>set_prior("&lt;prior&gt;", class = "b")</code>.
  This also leads to faster sampling, because priors can be vectorized in this case.
  Both ways of defining priors can be combined using for instance
  <code>set_prior("normal(0, 2)", class = "b")</code> and <br><code>set_prior("normal(0, 10)", class = "b", coef = "x1")</code>
  at the same time. This will set a <code>normal(0, 10)</code> prior on
  the effect of <code>x1</code> and a <code>normal(0, 2)</code> prior
  on all other population-level effects.
  However, this will break vectorization and
  may slow down the sampling procedure a bit.</p>
<p>In case of the default intercept parameterization
  (discussed in the 'Details' section of <code><a href="brmsformula.html">brmsformula</a></code>),
  general priors on class <code>"b"</code> will <em>not</em> affect
  the intercept. Instead, the intercept has its own parameter class
  named <code>"Intercept"</code> and priors can thus be
  specified via <code>set_prior("&lt;prior&gt;", class = "Intercept")</code>.
  Setting a prior on the intercept will not break vectorization
  of the other population-level effects.
  Note that technically, this prior is set on an intercept that
  results when internally centering all population-level predictors
  around zero to improve sampling efficiency. On this centered
  intercept, specifying a prior is actually much easier and
  intuitive than on the original intercept, since the former
  represents the expected response value when all predictors
  are at their means. To treat the intercept as an ordinary
  population-level effect and avoid the centering parameterization,
  use <code>0 + Intercept</code> on the right-hand side of the model formula.</p>
<p>In non-linear models, population-level effects are defined separately
  for each non-linear parameter. Accordingly, it is necessary to specify
  the non-linear parameter in <code>set_prior</code> so that priors
  we can be assigned correctly.
  If, for instance, <code>alpha</code> is the parameter and <code>x</code> the predictor
  for which we want to define the prior, we can write
  <code>set_prior("&lt;prior&gt;", coef = "x", nlpar = "alpha")</code>.
  As a shortcut we can use <code>set_prior("&lt;prior&gt;", nlpar = "alpha")</code>
  to set the same prior on all population-level effects of <code>alpha</code> at once.</p>
<p>The same goes for specifying priors for specific distributional
  parameters in the context of distributional regression, for example,
  <code>set_prior("&lt;prior&gt;", coef = "x", dpar = "sigma")</code>.
  For most other parameter classes (see below), you need to indicate
  non-linear and distributional parameters in the same way as shown here.</p>
<p>If desired, population-level effects can be restricted to fall only
  within a certain interval using the <code>lb</code> and <code>ub</code> arguments
  of <code>set_prior</code>. This is often required when defining priors
  that are not defined everywhere on the real line, such as uniform
  or gamma priors. When defining a <code>uniform(2,4)</code> prior,
  you should write <code>set_prior("uniform(2,4)", lb = 2, ub = 4)</code>.
  When using a prior that is defined on the positive reals only
  (such as a gamma prior) set <code>lb = 0</code>.
  In most situations, it is not useful to restrict population-level
  parameters through bounded priors
  (non-linear models are an important exception),
  but if you really want to this is the way to go.</p>
<p>2. Group-level ('random') effects</p>
<p>Each group-level effect of each grouping factor has a standard deviation named
  <code>sd_&lt;group&gt;_&lt;coef&gt;</code>. Consider, for instance, the formula
  <code>y ~ x1 + x2 + (1 + x1 | g)</code>.
  We see that the intercept as well as <code>x1</code> are group-level effects
  nested in the grouping factor <code>g</code>.
  The corresponding standard deviation parameters are named as
  <code>sd_g_Intercept</code> and <code>sd_g_x1</code> respectively.
  These parameters are restricted to be non-negative and, by default,
  have a half student-t prior with 3 degrees of freedom and a
  scale parameter that depends on the standard deviation of the response
  after applying the link function. Minimally, the scale parameter is 2.5.
  This prior is used (a) to be only weakly informative in order to influence
  results as few as possible, while (b) providing at least some regularization
  to considerably improve convergence and sampling efficiency.
  To define a prior distribution only for standard deviations
  of a specific grouping factor,
  use <br><code>set_prior("&lt;prior&gt;", class = "sd", group = "&lt;group&gt;")</code>.
  To define a prior distribution only for a specific standard deviation
  of a specific grouping factor, you may write <br><code>set_prior("&lt;prior&gt;", class = "sd", group = "&lt;group&gt;", coef = "&lt;coef&gt;")</code>.</p>
<p>If there is more than one group-level effect per grouping factor,
  the correlations between those effects have to be estimated.
  The prior <code>lkj_corr_cholesky(eta)</code> or in short
  <code>lkj(eta)</code> with <code>eta &gt; 0</code>
  is essentially the only prior for (Cholesky factors) of correlation matrices.
  If <code>eta = 1</code> (the default) all correlations matrices
  are equally likely a priori. If <code>eta &gt; 1</code>, extreme correlations
  become less likely, whereas <code>0 &lt; eta &lt; 1</code> results in
  higher probabilities for extreme correlations.
  Correlation matrix parameters in <code>brms</code> models are named as
  <code>cor_&lt;group&gt;</code>, (e.g., <code>cor_g</code> if <code>g</code> is the grouping factor).
  To set the same prior on every correlation matrix,
  use for instance <code>set_prior("lkj(2)", class = "cor")</code>.
  Internally, the priors are transformed to be put on the Cholesky factors
  of the correlation matrices to improve efficiency and numerical stability.
  The corresponding parameter class of the Cholesky factors is <code>L</code>,
  but it is not recommended to specify priors for this parameter class directly.</p>
<p>4. Smoothing Splines</p>
<p>Smoothing splines are implemented in <span class="pkg">brms</span> using the 'random effects'
  formulation as explained in <code><a href="https://rdrr.io/pkg/mgcv/man/gamm.html" class="external-link">gamm</a></code>). Thus, each
  spline has its corresponding standard deviations modeling the variability
  within this term. In <span class="pkg">brms</span>, this parameter class is called <code>sds</code>
  and priors can be specified via
  <code>set_prior("&lt;prior&gt;", class = "sds", coef = "&lt;term label&gt;")</code>.
  The default prior is the same as for standard deviations of group-level effects.</p>
<p>5. Gaussian processes</p>
<p>Gaussian processes as currently implemented in <span class="pkg">brms</span> have two
  parameters, the standard deviation parameter <code>sdgp</code>, and
  characteristic length-scale parameter <code>lscale</code> (see <code><a href="gp.html">gp</a></code>
  for more details). The default prior of <code>sdgp</code> is the same as for
  standard deviations of group-level effects. The default prior of
  <code>lscale</code> is an informative inverse-gamma prior specifically tuned to
  the covariates of the Gaussian process (for more details see
  <a href="https://betanalpha.github.io/assets/case_studies/gp_part3/part3.html" class="external-link">https://betanalpha.github.io/assets/case_studies/gp_part3/part3.html</a>).
  This tuned prior may be overly informative in some cases, so please
  consider other priors as well to make sure inference is robust to the prior
  specification. If tuning fails, a half-normal prior is used instead.</p>
<p>6. Autocorrelation parameters</p>
<p>The autocorrelation parameters currently implemented are named <code>ar</code>
  (autoregression), <code>ma</code> (moving average), <code>sderr</code> (standard
  deviation of latent residuals in latent ARMA models), <code>cosy</code> (compound
  symmetry correlation), <code>car</code> (spatial conditional autoregression), as
  well as <code>lagsar</code> and <code>errorsar</code> (spatial simultaneous
  autoregression).</p>
<p>Priors can be defined by <code>set_prior("&lt;prior&gt;", class = "ar")</code> for
  <code>ar</code> and similar for other autocorrelation parameters. By default,
  <code>ar</code> and <code>ma</code> are bounded between <code>-1</code> and <code>1</code>;
  <code>cosy</code>, <code>car</code>, <code>lagsar</code>, and <code>errorsar</code> are bounded
  between <code>0</code> and <code>1</code>. The default priors are flat over the
  respective definition areas.</p>
<p>7. Parameters of measurement error terms</p>
<p>Latent variables induced via measurement error <code><a href="me.html">me</a></code> terms
  require both mean and standard deviation parameters, whose prior classes
  are named <code>"meanme"</code> and <code>"sdme"</code>, respectively. If multiple
  latent variables are induced this way, their correlation matrix will
  be modeled as well and corresponding priors can be specified via the
  <code>"corme"</code> class. All of the above parameters have flat priors over
  their respective definition spaces by default.</p>
<p>8. Distance parameters of monotonic effects</p>
<p>As explained in the details section of <code><a href="brm.html">brm</a></code>,
  monotonic effects make use of a special parameter vector to
  estimate the 'normalized distances' between consecutive predictor
  categories. This is realized in <span class="pkg">Stan</span> using the <code>simplex</code>
  parameter type. This class is named <code>"simo"</code> (short for
  simplex monotonic) in <span class="pkg">brms</span>.
  The only valid prior for simplex parameters is the
  dirichlet prior, which accepts a vector of length <code>K - 1</code>
  (K = number of predictor categories) as input defining the
  'concentration' of the distribution. Explaining the dirichlet prior
  is beyond the scope of this documentation, but we want to describe
  how to define this prior syntactically correct.
  If a predictor <code>x</code> with <code>K</code> categories is modeled as monotonic,
  we can define a prior on its corresponding simplex via <br><code>prior(dirichlet(&lt;vector&gt;), class = simo, coef = mox1)</code>.
  The <code>1</code> in the end of <code>coef</code> indicates that this is the first
  simplex in this term. If interactions between multiple monotonic
  variables are modeled, multiple simplexes per term are required.
  For <code>&lt;vector&gt;</code>, we can put in any <code>R</code> expression
  defining a vector of length <code>K - 1</code>. The default is a uniform
  prior (i.e. <code>&lt;vector&gt; = rep(1, K-1)</code>) over all simplexes
  of the respective dimension.</p>
<p>9. Parameters for specific families</p>
<p>Some families need additional parameters to be estimated.
  Families <code>gaussian</code>, <code>student</code>, <code>skew_normal</code>,
  <code>lognormal</code>, and <code>gen_extreme_value</code> need the parameter
  <code>sigma</code> to account for the residual standard deviation.
  By default, <code>sigma</code> has a half student-t prior that scales
  in the same way as the group-level standard deviations.
  Further, family <code>student</code> needs the parameter
  <code>nu</code> representing the degrees of freedom of Student-t distribution.
  By default, <code>nu</code> has prior <code>gamma(2, 0.1)</code>, which is
  close to a penalized complexity prior (see Stan prior choice Wiki),
  and a fixed lower bound of <code>1</code>.
  Family <code>negbinomial</code> needs a <code>shape</code> parameter that has by
  default <code>inv_gamma(0.4, 0.3)</code> prior which is close to a
  penalized complexity prior (see Stan prior choice Wiki).
  Families <code>gamma</code>, <code>weibull</code>, and <code>inverse.gaussian</code>,
  need a <code>shape</code> parameter that has a <code>gamma(0.01, 0.01)</code>
  prior by default.
  For families <code>cumulative</code>, <code>cratio</code>, <code>sratio</code>,
  and <code>acat</code>, and only if <code>threshold = "equidistant"</code>,
  the parameter <code>delta</code> is used to model the distance between
  two adjacent thresholds.
  By default, <code>delta</code> has an improper flat prior over the reals.
  The <code>von_mises</code> family needs the parameter <code>kappa</code>, representing
  the concentration parameter. By default, <code>kappa</code> has prior
  <code>gamma(2, 0.01)</code>.</p>
<p>Every family specific parameter has its own prior class, so that
  <code>set_prior("&lt;prior&gt;", class = "&lt;parameter&gt;")</code> is the right way to go.
  All of these priors are chosen to be weakly informative,
  having only minimal influence on the estimations,
  while improving convergence and sampling efficiency.</p>
<p>10. Shrinkage priors</p>
<p>To reduce the danger of overfitting in models with many predictor terms fit
  on comparably sparse data, brms supports special shrinkage priors, namely
  the (regularized) <code><a href="horseshoe.html">horseshoe</a></code> and the <code><a href="R2D2.html">R2D2</a></code> prior.
  These priors can be applied on many parameter classes, either directly on
  the coefficient classes (e.g., class <code>b</code>), if directly setting priors
  on them is supported, or on the corresponding standard deviation
  hyperparameters (e.g., class <code>sd</code>) otherwise. Currently, the following
  classes support shrinkage priors: <code>b</code> (overall regression
  coefficients), <code>sds</code> (SDs of smoothing splines), <code>sdgp</code> (SDs of
  Gaussian processes), <code>ar</code> (autoregressive coefficients), <code>ma</code>
  (moving average coefficients), <code>sderr</code> (SD of latent residuals),
  <code>sdcar</code> (SD of spatial CAR structures), <code>sd</code> (SD of varying
  coefficients).</p>
<p>11. Fixing parameters to constants</p>
<p>Fixing parameters to constants is possible by using the <code>constant</code>
  function, for example, <code>constant(1)</code> to fix a parameter to 1.
  Broadcasting to vectors and matrices is done automatically.</p>
    </div>
    <div id="functions">
    <h2>Functions</h2>
    
<ul><li><p><code>prior()</code>: Alias of <code>set_prior</code> allowing to
specify arguments as expressions without quotation marks.</p></li>
<li><p><code>prior_()</code>: Alias of <code>set_prior</code> allowing to specify
arguments as as one-sided formulas or wrapped in <code>quote</code>.</p></li>
<li><p><code>prior_string()</code>: Alias of <code>set_prior</code> allowing to
specify arguments as strings.</p></li>
<li><p><code>empty_prior()</code>: Create an empty <code>brmsprior</code> object.</p></li>
</ul></div>
    <div id="see-also">
    <h2>See also</h2>
    <div class="dont-index"><p><code><a href="default_prior.default.html">default_prior</a></code></p></div>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co">## use alias functions</span></span></span>
<span class="r-in"><span><span class="op">(</span><span class="va">prior1</span> <span class="op">&lt;-</span> <span class="fu">prior</span><span class="op">(</span><span class="fu">cauchy</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">sd</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sd ~ cauchy(0, 1)</span>
<span class="r-in"><span><span class="op">(</span><span class="va">prior2</span> <span class="op">&lt;-</span> <span class="fu">prior_</span><span class="op">(</span><span class="op">~</span><span class="fu">cauchy</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span>, class <span class="op">=</span> <span class="op">~</span><span class="va">sd</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sd ~ cauchy(0, 1)</span>
<span class="r-in"><span><span class="op">(</span><span class="va">prior3</span> <span class="op">&lt;-</span> <span class="fu">prior_string</span><span class="op">(</span><span class="st">"cauchy(0, 1)"</span>, class <span class="op">=</span> <span class="st">"sd"</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sd ~ cauchy(0, 1)</span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/identical.html" class="external-link">identical</a></span><span class="op">(</span><span class="va">prior1</span>, <span class="va">prior2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/identical.html" class="external-link">identical</a></span><span class="op">(</span><span class="va">prior1</span>, <span class="va">prior3</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># check which parameters can have priors</span></span></span>
<span class="r-in"><span><span class="fu"><a href="default_prior.html">default_prior</a></span><span class="op">(</span><span class="va">rating</span> <span class="op">~</span> <span class="va">treat</span> <span class="op">+</span> <span class="va">period</span> <span class="op">+</span> <span class="va">carry</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">subject</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             data <span class="op">=</span> <span class="va">inhaler</span>, family <span class="op">=</span> <span class="fu"><a href="brmsfamily.html">cumulative</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 prior     class      coef   group resp dpar nlpar lb ub</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  student_t(3, 0, 2.5) Intercept                                        </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  student_t(3, 0, 2.5) Intercept         1                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  student_t(3, 0, 2.5) Intercept         2                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  student_t(3, 0, 2.5) Intercept         3                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                (flat)         b                                        </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                (flat)         b     carry                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                (flat)         b    period                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                (flat)         b     treat                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  student_t(3, 0, 2.5)        sd                                    0   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  student_t(3, 0, 2.5)        sd           subject                  0   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  student_t(3, 0, 2.5)        sd Intercept subject                  0   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        source</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       default</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  (vectorized)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  (vectorized)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  (vectorized)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       default</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  (vectorized)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  (vectorized)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  (vectorized)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       default</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  (vectorized)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  (vectorized)</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># define some priors</span></span></span>
<span class="r-in"><span><span class="va">bprior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu">prior_string</span><span class="op">(</span><span class="st">"normal(0,10)"</span>, class <span class="op">=</span> <span class="st">"b"</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            <span class="fu">prior</span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">b</span>, coef <span class="op">=</span> <span class="va">treat</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            <span class="fu">prior_</span><span class="op">(</span><span class="op">~</span><span class="fu">cauchy</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">2</span><span class="op">)</span>, class <span class="op">=</span> <span class="op">~</span><span class="va">sd</span>,</span></span>
<span class="r-in"><span>                   group <span class="op">=</span> <span class="op">~</span><span class="va">subject</span>, coef <span class="op">=</span> <span class="op">~</span><span class="va">Intercept</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># verify that the priors indeed found their way into Stan's model code</span></span></span>
<span class="r-in"><span><span class="fu"><a href="stancode.html">stancode</a></span><span class="op">(</span><span class="va">rating</span> <span class="op">~</span> <span class="va">treat</span> <span class="op">+</span> <span class="va">period</span> <span class="op">+</span> <span class="va">carry</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">subject</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>         data <span class="op">=</span> <span class="va">inhaler</span>, family <span class="op">=</span> <span class="fu"><a href="brmsfamily.html">cumulative</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>         prior <span class="op">=</span> <span class="va">bprior</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // generated with brms 2.22.0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   /* cumulative-logit log-PDF for a single response</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Args:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   y: response category</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   mu: latent mean parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   disc: discrimination parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   thres: ordinal thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Returns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   a scalar to be added to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    */</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    real cumulative_logit_lpmf(int y, real mu, real disc, vector thres) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      int nthres = num_elements(thres);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      if (y == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        return log_inv_logit(disc * (thres[1] - mu));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      } else if (y == nthres + 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        return log1m_inv_logit(disc * (thres[nthres] - mu));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        return log_inv_logit_diff(disc * (thres[y] - mu), disc * (thres[y - 1] - mu));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   /* cumulative-logit log-PDF for a single response and merged thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Args:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   y: response category</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   mu: latent mean parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   disc: discrimination parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   thres: vector of merged ordinal thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   j: start and end index for the applid threshold within 'thres'</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Returns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   a scalar to be added to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    */</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    real cumulative_logit_merged_lpmf(int y, real mu, real disc, vector thres, array[] int j) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      return cumulative_logit_lpmf(y | mu, disc, thres[j[1]:j[2]]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   /* ordered-logistic log-PDF for a single response and merged thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Args:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   y: response category</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   mu: latent mean parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   thres: vector of merged ordinal thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   j: start and end index for the applid threshold within 'thres'</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Returns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   a scalar to be added to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    */</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    real ordered_logistic_merged_lpmf(int y, real mu, vector thres, array[] int j) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      return ordered_logistic_lpmf(y | mu, thres[j[1]:j[2]]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N;  // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N] int Y;  // response variable</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=2&gt; nthres;  // number of thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; K;  // number of population-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, K] X;  // population-level design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; Kc;  // number of population-level effects after centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // data for group-level effects of ID 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N_1;  // number of grouping levels</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; M_1;  // number of coefficients per level</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N] int&lt;lower=1&gt; J_1;  // grouping indicator per observation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // group-level predictor values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[N] Z_1_1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int prior_only;  // should the likelihood be ignored?</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, Kc] Xc;  // centered version of X</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] means_X;  // column means of X before centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     means_X[i] = mean(X[, i]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     Xc[, i] = X[, i] - means_X[i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] b;  // regression coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ordered[nthres] Intercept;  // temporary thresholds for centered predictors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[M_1] sd_1;  // group-level standard deviations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[M_1] vector[N_1] z_1;  // standardized group-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real disc = 1;  // discrimination parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[N_1] r_1_1;  // actual group-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real lprior = 0;  // prior contributions to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   r_1_1 = (sd_1[1] * (z_1[1]));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += normal_lpdf(b[1] | 1, 2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += normal_lpdf(b[2] | 0,10);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += normal_lpdf(b[3] | 0,10);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += student_t_lpdf(Intercept | 3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += cauchy_lpdf(sd_1[1] | 0, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     - 1 * cauchy_lccdf(0 | 0, 2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // likelihood including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!prior_only) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // initialize linear predictor term</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N] mu = rep_vector(0.0, N);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mu += Xc * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1:N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       // add more terms to the linear predictor</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       mu[n] += r_1_1[J_1[n]] * Z_1_1[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1:N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += ordered_logistic_lpmf(Y[n] | mu[n], Intercept);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += lprior;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += std_normal_lpdf(z_1[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // compute actual thresholds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nthres] b_Intercept = Intercept + dot_product(means_X, b);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># use the horseshoe prior to model sparsity in regression coefficients</span></span></span>
<span class="r-in"><span><span class="fu"><a href="stancode.html">stancode</a></span><span class="op">(</span><span class="va">count</span> <span class="op">~</span> <span class="va">zAge</span> <span class="op">+</span> <span class="va">zBase</span> <span class="op">*</span> <span class="va">Trt</span>,</span></span>
<span class="r-in"><span>         data <span class="op">=</span> <span class="va">epilepsy</span>, family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>         prior <span class="op">=</span> <span class="fu">set_prior</span><span class="op">(</span><span class="st">"horseshoe(3)"</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // generated with brms 2.22.0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   /* Efficient computation of the horseshoe scale parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * see Appendix C.1 in https://projecteuclid.org/euclid.ejs/1513306866</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Args:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   lambda: local shrinkage parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   tau: global shrinkage parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   c2: slap regularization parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Returns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   scale parameter vector of the horseshoe prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    */</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector scales_horseshoe(vector lambda, real tau, real c2) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int K = rows(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[K] lambda2 = square(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[K] lambda_tilde = sqrt(c2 * lambda2 ./ (c2 + tau^2 * lambda2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return lambda_tilde * tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   /* compute scale parameters of the R2D2 prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Args:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   phi: local weight parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   tau2: global scale parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    * Returns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    *   scale parameter vector of the R2D2 prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    */</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector scales_R2D2(vector phi, real tau2) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return sqrt(phi * tau2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N;  // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N] int Y;  // response variable</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; K;  // number of population-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, K] X;  // population-level design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; Kc;  // number of population-level effects after centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; Kscales;  // number of local scale parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // data for the horseshoe prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; hs_df;  // local degrees of freedom</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; hs_df_global;  // global degrees of freedom</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; hs_df_slab;  // slab degrees of freedom</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; hs_scale_global;  // global prior scale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; hs_scale_slab;  // slab prior scale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int prior_only;  // should the likelihood be ignored?</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, Kc] Xc;  // centered version of X without an intercept</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] means_X;  // column means of X before centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 2:K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     means_X[i - 1] = mean(X[, i]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     Xc[, i - 1] = X[, i] - means_X[i - 1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] zb;  // unscaled coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real Intercept;  // temporary intercept for centered predictors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // horseshoe shrinkage parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; hs_global;  // global shrinkage parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; hs_slab;  // slab regularization parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[Kscales] hs_local;  // local parameters for the horseshoe prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] b;  // scaled coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[Kc] sdb;  // SDs of the coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[Kscales] scales;  // local horseshoe scale parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real lprior = 0;  // prior contributions to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // compute horseshoe scale parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   scales = scales_horseshoe(hs_local, hs_global, hs_scale_slab^2 * hs_slab);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sdb = scales[(1):(Kc)];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b = zb .* sdb;  // scale coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += student_t_lpdf(Intercept | 3, 1.4, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += student_t_lpdf(hs_global | hs_df_global, 0, hs_scale_global)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     - 1 * log(0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += inv_gamma_lpdf(hs_slab | 0.5 * hs_df_slab, 0.5 * hs_df_slab);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // likelihood including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!prior_only) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += poisson_log_glm_lpmf(Y | Xc, Intercept, b);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += lprior;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += std_normal_lpdf(zb);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += student_t_lpdf(hs_local | hs_df, 0, 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     - rows(hs_local) * log(0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // actual population-level intercept</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real b_Intercept = Intercept - dot_product(means_X, b);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># fix certain priors to constants</span></span></span>
<span class="r-in"><span><span class="va">bprior</span> <span class="op">&lt;-</span> <span class="fu">prior</span><span class="op">(</span><span class="fu"><a href="constant.html">constant</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, class <span class="op">=</span> <span class="st">"b"</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu">prior</span><span class="op">(</span><span class="fu"><a href="constant.html">constant</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>, class <span class="op">=</span> <span class="st">"b"</span>, coef <span class="op">=</span> <span class="st">"zBase"</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>  <span class="fu">prior</span><span class="op">(</span><span class="fu"><a href="constant.html">constant</a></span><span class="op">(</span><span class="fl">0.5</span><span class="op">)</span>, class <span class="op">=</span> <span class="st">"sd"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="stancode.html">stancode</a></span><span class="op">(</span><span class="va">count</span> <span class="op">~</span> <span class="va">zAge</span> <span class="op">+</span> <span class="va">zBase</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span> <span class="op">|</span> <span class="va">patient</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              data <span class="op">=</span> <span class="va">epilepsy</span>, prior <span class="op">=</span> <span class="va">bprior</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // generated with brms 2.22.0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N;  // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[N] Y;  // response variable</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; K;  // number of population-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, K] X;  // population-level design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; Kc;  // number of population-level effects after centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // data for group-level effects of ID 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N_1;  // number of grouping levels</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; M_1;  // number of coefficients per level</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N] int&lt;lower=1&gt; J_1;  // grouping indicator per observation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // group-level predictor values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[N] Z_1_1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int prior_only;  // should the likelihood be ignored?</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, Kc] Xc;  // centered version of X without an intercept</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] means_X;  // column means of X before centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 2:K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     means_X[i - 1] = mean(X[, i]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     Xc[, i - 1] = X[, i] - means_X[i - 1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real Intercept;  // temporary intercept for centered predictors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; sigma;  // dispersion parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[M_1] vector[N_1] z_1;  // standardized group-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] b;  // regression coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[M_1] sd_1;  // group-level standard deviations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[N_1] r_1_1;  // actual group-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real lprior = 0;  // prior contributions to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1] = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[2] = 2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sd_1 = rep_vector(0.5, rows(sd_1));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   r_1_1 = (sd_1[1] * (z_1[1]));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += student_t_lpdf(Intercept | 3, 4, 4.4);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += student_t_lpdf(sigma | 3, 0, 4.4)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     - 1 * student_t_lccdf(0 | 3, 0, 4.4);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // likelihood including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!prior_only) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // initialize linear predictor term</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N] mu = rep_vector(0.0, N);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mu += Intercept;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1:N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       // add more terms to the linear predictor</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       mu[n] += r_1_1[J_1[n]] * Z_1_1[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_id_glm_lpdf(Y | Xc, mu, b, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += lprior;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += std_normal_lpdf(z_1[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // actual population-level intercept</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real b_Intercept = Intercept - dot_product(means_X, b);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># pass priors to Stan without checking</span></span></span>
<span class="r-in"><span><span class="va">prior</span> <span class="op">&lt;-</span> <span class="fu">prior_string</span><span class="op">(</span><span class="st">"target += normal_lpdf(b[1] | 0, 1)"</span>, check <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="stancode.html">stancode</a></span><span class="op">(</span><span class="va">count</span> <span class="op">~</span> <span class="va">Trt</span>, data <span class="op">=</span> <span class="va">epilepsy</span>, prior <span class="op">=</span> <span class="va">prior</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // generated with brms 2.22.0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N;  // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[N] Y;  // response variable</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; K;  // number of population-level effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, K] X;  // population-level design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; Kc;  // number of population-level effects after centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int prior_only;  // should the likelihood be ignored?</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, Kc] Xc;  // centered version of X without an intercept</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] means_X;  // column means of X before centering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 2:K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     means_X[i - 1] = mean(X[, i]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     Xc[, i - 1] = X[, i] - means_X[i - 1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[Kc] b;  // regression coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real Intercept;  // temporary intercept for centered predictors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; sigma;  // dispersion parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real lprior = 0;  // prior contributions to the log posterior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += student_t_lpdf(Intercept | 3, 4, 4.4);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lprior += student_t_lpdf(sigma | 3, 0, 4.4)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     - 1 * student_t_lccdf(0 | 3, 0, 4.4);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // likelihood including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!prior_only) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors including constants</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += lprior;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   target += normal_lpdf(b[1] | 0, 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // actual population-level intercept</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real b_Intercept = Intercept - dot_product(means_X, b);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># define priors in a vectorized manner</span></span></span>
<span class="r-in"><span><span class="co"># useful in particular for categorical or multivariate models</span></span></span>
<span class="r-in"><span><span class="fu">set_prior</span><span class="op">(</span><span class="st">"normal(0, 2)"</span>, dpar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"muX"</span>, <span class="st">"muY"</span>, <span class="st">"muZ"</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         prior class coef group resp dpar nlpar   lb   ub source</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  normal(0, 2)     b                  muX       &lt;NA&gt; &lt;NA&gt;   user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  normal(0, 2)     b                  muY       &lt;NA&gt; &lt;NA&gt;   user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  normal(0, 2)     b                  muZ       &lt;NA&gt; &lt;NA&gt;   user</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Paul-Christian Bürkner.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

